################################################################################
# NEKO COMPREHENSIVE TESTING WORKFLOW
# ============================================================================
# This workflow performs exhaustive testing of the Neko Bug Bounty Framework
# from installation through all features with EXTREMELY DETAILED LOGGING.
# 
# WHAT THIS TESTS:
# - Full installation process simulation
# - All library loading and initialization
# - All module loading and function availability
# - Core function execution and edge cases
# - Configuration parsing and validation
# - Inter-library dependencies
# - Error handling mechanisms
# - Data flow and orchestration systems
# - File structure and permissions
#
# WHAT THIS DOES NOT TEST (excluded by design):
# - Actual target scanning
# - Discord/Slack/Telegram notifications
# - External API connectivity tests
#
# LOGGING: All logs are collected as artifacts with timestamps, stack traces,
# memory usage, and execution times for comprehensive debugging.
################################################################################

name: Neko Comprehensive Testing

on:
  push:
    branches: [main, master, develop, 'feature/**', 'test/**']
  pull_request:
    branches: [main, master, develop]
  workflow_dispatch:
    inputs:
      debug_level:
        description: 'Debug verbosity level (1-5, 5 being most verbose)'
        required: false
        default: '5'
        type: choice
        options:
          - '1'
          - '2'
          - '3'
          - '4'
          - '5'
      test_installation:
        description: 'Run full installation tests'
        required: false
        default: 'true'
        type: boolean
      test_all_modules:
        description: 'Test all module functions individually'
        required: false
        default: 'true'
        type: boolean

env:
  DEBUG_LEVEL: ${{ github.event.inputs.debug_level || '5' }}
  TIMESTAMP_FORMAT: '%Y-%m-%d %H:%M:%S.%3N'
  TOOLS_PATH: /home/runner/Tools
  WORDLISTS_PATH: /home/runner/Tools/wordlists
  LOG_COLORS: 'true'
  VERBOSE_OUTPUT: 'true'

################################################################################
# JOBS
################################################################################

jobs:
  ################################################################################
  # JOB 1: Initialize Test Environment
  ################################################################################
  init-environment:
    name: "1. Initialize Environment"
    runs-on: ubuntu-latest
    outputs:
      run_id: ${{ steps.init.outputs.run_id }}
      timestamp: ${{ steps.init.outputs.timestamp }}
      log_prefix: ${{ steps.init.outputs.log_prefix }}
    steps:
      - name: Generate Run Identifiers
        id: init
        run: |
          TIMESTAMP=$(date +"%Y%m%d_%H%M%S")
          RUN_ID="${TIMESTAMP}_run${{ github.run_number }}_${{ github.run_attempt }}"
          LOG_PREFIX="neko_test_${RUN_ID}"
          
          echo "run_id=${RUN_ID}" >> $GITHUB_OUTPUT
          echo "timestamp=${TIMESTAMP}" >> $GITHUB_OUTPUT
          echo "log_prefix=${LOG_PREFIX}" >> $GITHUB_OUTPUT
          
          cat << 'EOF'
          ╔══════════════════════════════════════════════════════════════════════════════╗
          ║                    NEKO COMPREHENSIVE TESTING SUITE                          ║
          ╠══════════════════════════════════════════════════════════════════════════════╣
          ║  This workflow performs exhaustive testing with detailed logging.            ║
          ║  All logs will be available as downloadable artifacts.                       ║
          ╚══════════════════════════════════════════════════════════════════════════════╝
          EOF
          
          echo ""
          echo "══════════════════════════════════════════════════════════════════════════════"
          echo "RUN INFORMATION"
          echo "══════════════════════════════════════════════════════════════════════════════"
          echo "Run ID:        ${RUN_ID}"
          echo "Timestamp:     ${TIMESTAMP}"
          echo "Log Prefix:    ${LOG_PREFIX}"
          echo "GitHub Event:  ${{ github.event_name }}"
          echo "GitHub Ref:    ${{ github.ref }}"
          echo "GitHub SHA:    ${{ github.sha }}"
          echo "Runner OS:     ${{ runner.os }}"
          echo "Debug Level:   ${DEBUG_LEVEL}"
          echo "══════════════════════════════════════════════════════════════════════════════"

      - name: Collect System Information
        run: |
          echo "══════════════════════════════════════════════════════════════════════════════"
          echo "SYSTEM INFORMATION"
          echo "══════════════════════════════════════════════════════════════════════════════"
          
          echo ""
          echo "─── Operating System ───"
          cat /etc/os-release
          
          echo ""
          echo "─── Kernel ───"
          uname -a
          
          echo ""
          echo "─── CPU ───"
          lscpu | grep -E "^(Architecture|CPU\(s\)|Model name|CPU MHz)"
          
          echo ""
          echo "─── Memory ───"
          free -h
          
          echo ""
          echo "─── Disk ───"
          df -h / /tmp
          
          echo ""
          echo "─── Bash Version ───"
          bash --version | head -1
          
          echo ""
          echo "─── Available Shells ───"
          cat /etc/shells
          
          echo ""
          echo "─── User Context ───"
          echo "User: $(whoami)"
          echo "Home: $HOME"
          echo "PWD:  $(pwd)"
          
          echo ""
          echo "─── Environment Variables (non-sensitive) ───"
          env | grep -v -E "(KEY|TOKEN|SECRET|PASS|CRED)" | sort
          
          echo ""
          echo "══════════════════════════════════════════════════════════════════════════════"

  ################################################################################
  # JOB 2: Deep Syntax Analysis
  ################################################################################
  syntax-analysis:
    name: "2. Deep Syntax Analysis"
    runs-on: ubuntu-latest
    needs: init-environment
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Create Log Structure
        run: |
          mkdir -p logs/syntax/{detailed,errors,warnings,scripts}
          echo "Log directory structure created"
          echo "Run ID: ${{ needs.init-environment.outputs.run_id }}" > logs/syntax/run_info.txt
          echo "Started: $(date)" >> logs/syntax/run_info.txt

      - name: Install Analysis Tools
        run: |
          echo "══════════════════════════════════════════════════════════════════════════════"
          echo "INSTALLING ANALYSIS TOOLS"
          echo "══════════════════════════════════════════════════════════════════════════════"
          sudo apt-get update
          sudo apt-get install -y shellcheck
          shellcheck --version

      - name: Comprehensive Bash Syntax Validation
        id: bash_syntax
        run: |
          echo "══════════════════════════════════════════════════════════════════════════════"
          echo "COMPREHENSIVE BASH SYNTAX VALIDATION"
          echo "══════════════════════════════════════════════════════════════════════════════"
          
          MASTER_LOG="logs/syntax/master_syntax_report.log"
          SUMMARY_LOG="logs/syntax/summary.log"
          
          # Initialize logs with headers
          cat << 'HEADER' > "$MASTER_LOG"
          ══════════════════════════════════════════════════════════════════════════════
          NEKO SYNTAX VALIDATION MASTER REPORT
          ══════════════════════════════════════════════════════════════════════════════
          
          HEADER
          
          echo "Run ID: ${{ needs.init-environment.outputs.run_id }}" >> "$MASTER_LOG"
          echo "Timestamp: $(date '+%Y-%m-%d %H:%M:%S.%3N')" >> "$MASTER_LOG"
          echo "" >> "$MASTER_LOG"
          
          # Counters
          TOTAL=0
          PASSED=0
          FAILED=0
          WARNINGS=0
          
          # Find all shell scripts
          echo "Finding all shell scripts..." >> "$MASTER_LOG"
          find . -type f \( -name "*.sh" -o -name "*.bash" \) ! -path "./.git/*" > /tmp/scripts.txt
          
          echo "Found $(wc -l < /tmp/scripts.txt) scripts to analyze" >> "$MASTER_LOG"
          echo "" >> "$MASTER_LOG"
          
          while IFS= read -r script; do
            TOTAL=$((TOTAL + 1))
            SCRIPT_NAME=$(basename "$script")
            SCRIPT_LOG="logs/syntax/scripts/${SCRIPT_NAME%.sh}_analysis.log"
            
            echo "════════════════════════════════════════════════════════════════" >> "$MASTER_LOG"
            echo "SCRIPT: $script" >> "$MASTER_LOG"
            echo "════════════════════════════════════════════════════════════════" >> "$MASTER_LOG"
            
            # Detailed script info
            echo "" >> "$MASTER_LOG"
            echo "─── File Information ───" >> "$MASTER_LOG"
            echo "  Path:        $script" >> "$MASTER_LOG"
            echo "  Size:        $(wc -c < "$script") bytes" >> "$MASTER_LOG"
            echo "  Lines:       $(wc -l < "$script")" >> "$MASTER_LOG"
            echo "  Permissions: $(stat -c %a "$script" 2>/dev/null || stat -f %p "$script" 2>/dev/null || echo 'unknown')" >> "$MASTER_LOG"
            
            # Check shebang
            SHEBANG=$(head -1 "$script")
            echo "  Shebang:     $SHEBANG" >> "$MASTER_LOG"
            
            if [[ ! "$SHEBANG" =~ ^#! ]]; then
              echo "  [WARNING] No shebang line detected" >> "$MASTER_LOG"
              WARNINGS=$((WARNINGS + 1))
            fi
            
            echo "" >> "$MASTER_LOG"
            echo "─── Syntax Check (bash -n) ───" >> "$MASTER_LOG"
            
            # Run bash -n and capture output
            if bash -n "$script" 2> /tmp/syntax_err_$$.txt; then
              echo "  [PASS] Syntax is valid" >> "$MASTER_LOG"
              PASSED=$((PASSED + 1))
            else
              echo "  [FAIL] Syntax errors detected:" >> "$MASTER_LOG"
              cat /tmp/syntax_err_$$.txt | sed 's/^/    /' >> "$MASTER_LOG"
              cat /tmp/syntax_err_$$.txt >> "logs/syntax/errors/${SCRIPT_NAME%.sh}_errors.log"
              FAILED=$((FAILED + 1))
            fi
            rm -f /tmp/syntax_err_$$.txt
            
            echo "" >> "$MASTER_LOG"
            echo "─── Function Definitions ───" >> "$MASTER_LOG"
            
            # Extract function names
            grep -E '^\s*(function\s+)?[a-zA-Z_][a-zA-Z0-9_]*\s*\(\)' "$script" 2>/dev/null | head -20 | sed 's/^/    /' >> "$MASTER_LOG" || echo "    No functions found" >> "$MASTER_LOG"
            
            echo "" >> "$MASTER_LOG"
            echo "─── Variable Declarations ───" >> "$MASTER_LOG"
            
            # Extract key variable declarations
            grep -E '^\s*(declare|local|export|readonly)\s+' "$script" 2>/dev/null | head -20 | sed 's/^/    /' >> "$MASTER_LOG" || echo "    No explicit declarations found" >> "$MASTER_LOG"
            
            echo "" >> "$MASTER_LOG"
            echo "─── Source/Include Statements ───" >> "$MASTER_LOG"
            
            # Find source statements
            grep -nE '^\s*(source|\.)\s+' "$script" 2>/dev/null | sed 's/^/    /' >> "$MASTER_LOG" || echo "    No source statements" >> "$MASTER_LOG"
            
            echo "" >> "$MASTER_LOG"
            
          done < /tmp/scripts.txt
          
          # Summary
          cat << EOF >> "$MASTER_LOG"
          
          ══════════════════════════════════════════════════════════════════════════════
          SYNTAX VALIDATION SUMMARY
          ══════════════════════════════════════════════════════════════════════════════
          
          Total Scripts:    $TOTAL
          Passed:           $PASSED
          Failed:           $FAILED
          Warnings:         $WARNINGS
          
          Success Rate:     $(echo "scale=2; $PASSED * 100 / $TOTAL" | bc)%
          
          ══════════════════════════════════════════════════════════════════════════════
          EOF
          
          # Also create summary log
          cat << EOF > "$SUMMARY_LOG"
          SYNTAX VALIDATION SUMMARY
          ========================
          Total:    $TOTAL
          Passed:   $PASSED
          Failed:   $FAILED
          Warnings: $WARNINGS
          EOF
          
          # Output to console
          cat "$MASTER_LOG"
          
          # Set outputs
          echo "total=$TOTAL" >> $GITHUB_OUTPUT
          echo "passed=$PASSED" >> $GITHUB_OUTPUT
          echo "failed=$FAILED" >> $GITHUB_OUTPUT
          
          # Fail if any syntax errors
          if [[ $FAILED -gt 0 ]]; then
            echo ""
            echo "[ERROR] $FAILED scripts have syntax errors!"
            exit 1
          fi

      - name: ShellCheck Deep Analysis
        id: shellcheck
        continue-on-error: true
        run: |
          echo "══════════════════════════════════════════════════════════════════════════════"
          echo "SHELLCHECK DEEP ANALYSIS"
          echo "══════════════════════════════════════════════════════════════════════════════"
          
          SC_REPORT="logs/syntax/shellcheck_full_report.log"
          SC_SUMMARY="logs/syntax/shellcheck_summary.log"
          
          cat << 'HEADER' > "$SC_REPORT"
          ══════════════════════════════════════════════════════════════════════════════
          SHELLCHECK ANALYSIS REPORT
          ══════════════════════════════════════════════════════════════════════════════
          
          ShellCheck is a static analysis tool for shell scripts.
          It detects bugs, style issues, and potential problems.
          
          Severity Levels:
            error   - Definite problems that will cause incorrect behavior
            warning - Issues that may cause problems
            info    - Suggestions and stylistic issues
            style   - Pure style issues
          
          ══════════════════════════════════════════════════════════════════════════════
          
          HEADER
          
          TOTAL_ERRORS=0
          TOTAL_WARNINGS=0
          TOTAL_INFO=0
          TOTAL_STYLE=0
          
          while IFS= read -r script; do
            SCRIPT_NAME=$(basename "$script")
            
            echo "" >> "$SC_REPORT"
            echo "════════════════════════════════════════════════════════════════" >> "$SC_REPORT"
            echo "FILE: $script" >> "$SC_REPORT"
            echo "════════════════════════════════════════════════════════════════" >> "$SC_REPORT"
            
            # Run shellcheck with different output formats
            echo "" >> "$SC_REPORT"
            echo "─── GCC Format Output ───" >> "$SC_REPORT"
            
            shellcheck -x -s bash -f gcc "$script" 2>&1 | tee /tmp/sc_out_$$.txt >> "$SC_REPORT" || true
            
            # Count issues by severity
            E=$(grep -c ":error:" /tmp/sc_out_$$.txt 2>/dev/null || echo 0)
            W=$(grep -c ":warning:" /tmp/sc_out_$$.txt 2>/dev/null || echo 0)
            I=$(grep -c ":note:" /tmp/sc_out_$$.txt 2>/dev/null || echo 0)
            
            TOTAL_ERRORS=$((TOTAL_ERRORS + E))
            TOTAL_WARNINGS=$((TOTAL_WARNINGS + W))
            TOTAL_INFO=$((TOTAL_INFO + I))
            
            echo "" >> "$SC_REPORT"
            echo "Summary for $SCRIPT_NAME: Errors=$E, Warnings=$W, Notes=$I" >> "$SC_REPORT"
            
            rm -f /tmp/sc_out_$$.txt
            
          done < <(find . -type f -name "*.sh" ! -path "./.git/*")
          
          # Write summary
          cat << EOF >> "$SC_REPORT"
          
          ══════════════════════════════════════════════════════════════════════════════
          SHELLCHECK ANALYSIS SUMMARY
          ══════════════════════════════════════════════════════════════════════════════
          
          Total Errors:   $TOTAL_ERRORS
          Total Warnings: $TOTAL_WARNINGS
          Total Info:     $TOTAL_INFO
          
          ══════════════════════════════════════════════════════════════════════════════
          EOF
          
          cat << EOF > "$SC_SUMMARY"
          SHELLCHECK SUMMARY
          ==================
          Errors:   $TOTAL_ERRORS
          Warnings: $TOTAL_WARNINGS
          Info:     $TOTAL_INFO
          EOF
          
          # Show last 100 lines of report
          tail -100 "$SC_REPORT"

      - name: Check Common Bash Pitfalls
        run: |
          echo "══════════════════════════════════════════════════════════════════════════════"
          echo "COMMON BASH PITFALLS CHECK"
          echo "══════════════════════════════════════════════════════════════════════════════"
          
          PITFALL_LOG="logs/syntax/pitfall_analysis.log"
          
          cat << 'HEADER' > "$PITFALL_LOG"
          ══════════════════════════════════════════════════════════════════════════════
          COMMON BASH PITFALLS ANALYSIS
          ══════════════════════════════════════════════════════════════════════════════
          
          This analysis checks for common bash scripting mistakes that may cause issues.
          
          HEADER
          
          echo "" >> "$PITFALL_LOG"
          echo "─── Unquoted Variable Expansions in Tests ───" >> "$PITFALL_LOG"
          echo "(Using [ \$var ] instead of [ \"\$var\" ] can cause word splitting)" >> "$PITFALL_LOG"
          echo "" >> "$PITFALL_LOG"
          grep -rn '\[ \$[A-Za-z_]' --include="*.sh" . 2>/dev/null | head -30 >> "$PITFALL_LOG" || echo "None found" >> "$PITFALL_LOG"
          
          echo "" >> "$PITFALL_LOG"
          echo "─── Using == in [ ] Instead of = ───" >> "$PITFALL_LOG"
          echo "(POSIX requires = for string comparison in [ ])" >> "$PITFALL_LOG"
          echo "" >> "$PITFALL_LOG"
          grep -rn '\[ .* == ' --include="*.sh" . 2>/dev/null | head -30 >> "$PITFALL_LOG" || echo "None found" >> "$PITFALL_LOG"
          
          echo "" >> "$PITFALL_LOG"
          echo "─── Potential Command Injection via Eval ───" >> "$PITFALL_LOG"
          echo "" >> "$PITFALL_LOG"
          grep -rn 'eval ' --include="*.sh" . 2>/dev/null | head -30 >> "$PITFALL_LOG" || echo "None found" >> "$PITFALL_LOG"
          
          echo "" >> "$PITFALL_LOG"
          echo "─── Unquoted Command Substitution ───" >> "$PITFALL_LOG"
          echo "" >> "$PITFALL_LOG"
          grep -rn '\$([^)]*)' --include="*.sh" . 2>/dev/null | grep -v '"' | head -30 >> "$PITFALL_LOG" || echo "None found or all quoted" >> "$PITFALL_LOG"
          
          echo "" >> "$PITFALL_LOG"
          echo "─── cd Without Error Checking ───" >> "$PITFALL_LOG"
          echo "" >> "$PITFALL_LOG"
          grep -rn '^[[:space:]]*cd ' --include="*.sh" . 2>/dev/null | grep -v '||' | grep -v '&&' | head -30 >> "$PITFALL_LOG" || echo "None found" >> "$PITFALL_LOG"
          
          echo "" >> "$PITFALL_LOG"
          echo "─── Potential Race Conditions (temp files) ───" >> "$PITFALL_LOG"
          echo "" >> "$PITFALL_LOG"
          grep -rn '/tmp/[a-zA-Z]*\.' --include="*.sh" . 2>/dev/null | grep -v '\$\$' | head -30 >> "$PITFALL_LOG" || echo "None found" >> "$PITFALL_LOG"
          
          cat "$PITFALL_LOG"

      - name: Upload Syntax Analysis Logs
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: syntax-analysis-${{ needs.init-environment.outputs.run_id }}
          path: logs/syntax/
          retention-days: 30

  ################################################################################
  # JOB 3: Configuration Deep Validation
  ################################################################################
  config-validation:
    name: "3. Configuration Validation"
    runs-on: ubuntu-latest
    needs: init-environment
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Create Log Structure
        run: |
          mkdir -p logs/config/{variables,sections,validation}
          echo "Run ID: ${{ needs.init-environment.outputs.run_id }}" > logs/config/run_info.txt

      - name: Deep Configuration Analysis
        run: |
          echo "══════════════════════════════════════════════════════════════════════════════"
          echo "DEEP CONFIGURATION ANALYSIS"
          echo "══════════════════════════════════════════════════════════════════════════════"
          
          CONFIG_REPORT="logs/config/full_config_report.log"
          VAR_REPORT="logs/config/variables/all_variables.log"
          
          CONFIG_FILE="neko.cfg"
          
          cat << 'HEADER' > "$CONFIG_REPORT"
          ══════════════════════════════════════════════════════════════════════════════
          NEKO CONFIGURATION ANALYSIS REPORT
          ══════════════════════════════════════════════════════════════════════════════
          
          HEADER
          
          echo "Timestamp: $(date '+%Y-%m-%d %H:%M:%S.%3N')" >> "$CONFIG_REPORT"
          echo "" >> "$CONFIG_REPORT"
          
          # File check
          echo "─── Configuration File ───" >> "$CONFIG_REPORT"
          if [[ -f "$CONFIG_FILE" ]]; then
            echo "File exists: YES" >> "$CONFIG_REPORT"
            echo "Size: $(wc -c < "$CONFIG_FILE") bytes" >> "$CONFIG_REPORT"
            echo "Lines: $(wc -l < "$CONFIG_FILE")" >> "$CONFIG_REPORT"
            echo "MD5: $(md5sum "$CONFIG_FILE" | cut -d' ' -f1)" >> "$CONFIG_REPORT"
          else
            echo "[CRITICAL] Configuration file not found!" >> "$CONFIG_REPORT"
            exit 1
          fi
          
          echo "" >> "$CONFIG_REPORT"
          echo "─── Syntax Validation ───" >> "$CONFIG_REPORT"
          
          if bash -n "$CONFIG_FILE" 2>&1 | tee -a "$CONFIG_REPORT"; then
            echo "Syntax: VALID" >> "$CONFIG_REPORT"
          else
            echo "Syntax: INVALID" >> "$CONFIG_REPORT"
            exit 1
          fi
          
          echo "" >> "$CONFIG_REPORT"
          echo "─── Variable Extraction ───" >> "$CONFIG_REPORT"
          
          # Extract all variable definitions
          echo "Extracting all variable definitions..." >> "$CONFIG_REPORT"
          grep -E '^\s*[A-Z_][A-Z0-9_]*=' "$CONFIG_FILE" > "$VAR_REPORT" 2>/dev/null || true
          
          VAR_COUNT=$(wc -l < "$VAR_REPORT")
          echo "Total variables defined: $VAR_COUNT" >> "$CONFIG_REPORT"
          
          echo "" >> "$CONFIG_REPORT"
          echo "─── Configuration Sections ───" >> "$CONFIG_REPORT"
          
          # Find section headers
          grep -n '═' "$CONFIG_FILE" 2>/dev/null | head -50 >> "$CONFIG_REPORT" || true
          
          echo "" >> "$CONFIG_REPORT"
          echo "─── Required Variables Check ───" >> "$CONFIG_REPORT"
          
          # Source config and check required vars
          source "$CONFIG_FILE" 2>/dev/null || true
          
          REQUIRED_VARS=(
            "TOOLS_PATH"
            "USER_AGENT"
            "OSINT_ENABLED"
            "SUBDOMAIN_ENABLED"
            "DNS_ENABLED"
            "WEBPROBE_ENABLED"
            "PORTSCAN_ENABLED"
            "CONTENT_ENABLED"
            "FINGERPRINT_ENABLED"
            "URLANALYSIS_ENABLED"
            "PARAM_ENABLED"
            "VULNSCAN_ENABLED"
            "XSS_ENABLED"
            "TAKEOVER_ENABLED"
            "CLOUD_ENABLED"
            "AUTH_ENABLED"
            "API_ENABLED"
            "REPORT_ENABLED"
          )
          
          MISSING=0
          for var in "${REQUIRED_VARS[@]}"; do
            if [[ -z "${!var+x}" ]]; then
              echo "[MISSING] $var" >> "$CONFIG_REPORT"
              MISSING=$((MISSING + 1))
            else
              echo "[OK] $var = ${!var}" >> "$CONFIG_REPORT"
            fi
          done
          
          echo "" >> "$CONFIG_REPORT"
          echo "Missing required variables: $MISSING" >> "$CONFIG_REPORT"
          
          echo "" >> "$CONFIG_REPORT"
          echo "─── Thread Configuration ───" >> "$CONFIG_REPORT"
          
          THREAD_VARS=$(grep -E '^\s*[A-Z_]*_THREADS=' "$CONFIG_FILE" 2>/dev/null)
          echo "$THREAD_VARS" >> "$CONFIG_REPORT"
          
          echo "" >> "$CONFIG_REPORT"
          echo "─── Rate Limit Configuration ───" >> "$CONFIG_REPORT"
          
          RATE_VARS=$(grep -E '^\s*[A-Z_]*_RATE' "$CONFIG_FILE" 2>/dev/null)
          echo "$RATE_VARS" >> "$CONFIG_REPORT"
          
          echo "" >> "$CONFIG_REPORT"
          echo "─── Timeout Configuration ───" >> "$CONFIG_REPORT"
          
          TIMEOUT_VARS=$(grep -E '^\s*[A-Z_]*_TIMEOUT' "$CONFIG_FILE" 2>/dev/null)
          echo "$TIMEOUT_VARS" >> "$CONFIG_REPORT"
          
          cat "$CONFIG_REPORT"

      - name: Validate plugins.json
        run: |
          echo "══════════════════════════════════════════════════════════════════════════════"
          echo "PLUGINS CONFIGURATION VALIDATION"
          echo "══════════════════════════════════════════════════════════════════════════════"
          
          PLUGINS_LOG="logs/config/plugins_validation.log"
          PLUGINS_FILE="config/plugins.json"
          
          if [[ -f "$PLUGINS_FILE" ]]; then
            echo "Validating: $PLUGINS_FILE" | tee "$PLUGINS_LOG"
            
            if jq '.' "$PLUGINS_FILE" > /dev/null 2>&1; then
              echo "[PASS] Valid JSON structure" | tee -a "$PLUGINS_LOG"
              echo "" >> "$PLUGINS_LOG"
              echo "Content:" >> "$PLUGINS_LOG"
              jq '.' "$PLUGINS_FILE" >> "$PLUGINS_LOG"
            else
              echo "[FAIL] Invalid JSON" | tee -a "$PLUGINS_LOG"
              echo "Raw content:" >> "$PLUGINS_LOG"
              cat "$PLUGINS_FILE" >> "$PLUGINS_LOG"
            fi
          else
            echo "[SKIP] plugins.json not found" | tee "$PLUGINS_LOG"
          fi

      - name: Upload Config Logs
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: config-validation-${{ needs.init-environment.outputs.run_id }}
          path: logs/config/
          retention-days: 30

  ################################################################################
  # JOB 4: File Structure Validation
  ################################################################################
  structure-validation:
    name: "4. Structure Validation"
    runs-on: ubuntu-latest
    needs: init-environment
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Create Log Structure
        run: |
          mkdir -p logs/structure
          echo "Run ID: ${{ needs.init-environment.outputs.run_id }}" > logs/structure/run_info.txt

      - name: Complete Structure Analysis
        run: |
          echo "══════════════════════════════════════════════════════════════════════════════"
          echo "COMPLETE STRUCTURE ANALYSIS"
          echo "══════════════════════════════════════════════════════════════════════════════"
          
          STRUCT_LOG="logs/structure/full_structure_report.log"
          
          cat << 'HEADER' > "$STRUCT_LOG"
          ══════════════════════════════════════════════════════════════════════════════
          NEKO PROJECT STRUCTURE ANALYSIS
          ══════════════════════════════════════════════════════════════════════════════
          
          HEADER
          
          echo "Timestamp: $(date '+%Y-%m-%d %H:%M:%S.%3N')" >> "$STRUCT_LOG"
          echo "" >> "$STRUCT_LOG"
          
          # Required directories
          echo "─── Required Directories ───" >> "$STRUCT_LOG"
          echo "" >> "$STRUCT_LOG"
          
          DIRS=(
            "modules:Core scanning modules"
            "lib:Shared libraries"
            "config:Configuration files"
            "plugins:Plugin directory"
          )
          
          MISSING_DIRS=0
          for dir_info in "${DIRS[@]}"; do
            dir="${dir_info%%:*}"
            desc="${dir_info#*:}"
            
            if [[ -d "$dir" ]]; then
              COUNT=$(find "$dir" -type f 2>/dev/null | wc -l)
              echo "[OK] $dir/ - $desc ($COUNT files)" >> "$STRUCT_LOG"
            else
              echo "[MISSING] $dir/ - $desc" >> "$STRUCT_LOG"
              MISSING_DIRS=$((MISSING_DIRS + 1))
            fi
          done
          
          echo "" >> "$STRUCT_LOG"
          echo "Missing directories: $MISSING_DIRS" >> "$STRUCT_LOG"
          
          # Required files
          echo "" >> "$STRUCT_LOG"
          echo "─── Required Files ───" >> "$STRUCT_LOG"
          echo "" >> "$STRUCT_LOG"
          
          FILES=(
            "neko.sh:Main script"
            "neko.cfg:Configuration file"
            "install.sh:Installation script"
            "README.md:Documentation"
            "run_tests.sh:Test suite"
          )
          
          MISSING_FILES=0
          for file_info in "${FILES[@]}"; do
            file="${file_info%%:*}"
            desc="${file_info#*:}"
            
            if [[ -f "$file" ]]; then
              SIZE=$(wc -c < "$file")
              LINES=$(wc -l < "$file")
              echo "[OK] $file - $desc ($LINES lines, $SIZE bytes)" >> "$STRUCT_LOG"
            else
              echo "[MISSING] $file - $desc" >> "$STRUCT_LOG"
              MISSING_FILES=$((MISSING_FILES + 1))
            fi
          done
          
          echo "" >> "$STRUCT_LOG"
          echo "Missing files: $MISSING_FILES" >> "$STRUCT_LOG"
          
          # Module files
          echo "" >> "$STRUCT_LOG"
          echo "─── Module Files ───" >> "$STRUCT_LOG"
          echo "" >> "$STRUCT_LOG"
          
          MODULES=(
            "00_osint.sh:OSINT & Intelligence"
            "01_subdomain.sh:Subdomain Discovery"
            "02_dns.sh:DNS Analysis"
            "03_webprobe.sh:Web Probing"
            "04_portscan.sh:Port Scanning"
            "05_content.sh:Content Discovery"
            "06_fingerprint.sh:Fingerprinting"
            "07_urlanalysis.sh:URL Analysis"
            "08_params.sh:Parameter Discovery"
            "09_vulnscan.sh:Vulnerability Scanning"
            "10_xss.sh:XSS Detection"
            "11_takeover.sh:Subdomain Takeover"
            "12_cloud.sh:Cloud Security"
            "13_auth.sh:Authentication Testing"
            "14_api.sh:API Security"
            "15_report.sh:Report Generation"
            "16_advanced_vulns.sh:Advanced Vulnerabilities"
            "17_bettercap.sh:Bettercap Integration"
          )
          
          MISSING_MODULES=0
          for mod_info in "${MODULES[@]}"; do
            mod="${mod_info%%:*}"
            desc="${mod_info#*:}"
            
            if [[ -f "modules/$mod" ]]; then
              LINES=$(wc -l < "modules/$mod")
              echo "[OK] modules/$mod - $desc ($LINES lines)" >> "$STRUCT_LOG"
            else
              echo "[MISSING] modules/$mod - $desc" >> "$STRUCT_LOG"
              MISSING_MODULES=$((MISSING_MODULES + 1))
            fi
          done
          
          echo "" >> "$STRUCT_LOG"
          echo "Missing modules: $MISSING_MODULES" >> "$STRUCT_LOG"
          
          # Library files
          echo "" >> "$STRUCT_LOG"
          echo "─── Library Files ───" >> "$STRUCT_LOG"
          echo "" >> "$STRUCT_LOG"
          
          LIBS=(
            "core.sh:Core utilities"
            "logging.sh:Logging system"
            "discord_notifications.sh:Discord integration"
            "parallel.sh:Parallel processing"
            "async_pipeline.sh:Async pipeline"
            "error_handling.sh:Error handling"
            "error_reporting.sh:Error reporting"
            "queue_manager.sh:Queue management"
            "data_flow_bus.sh:Data flow bus"
            "orchestrator.sh:Orchestration"
            "proxy_rotation.sh:Proxy rotation"
            "intelligence.sh:Intelligence engine"
            "plugin.sh:Plugin system"
          )
          
          MISSING_LIBS=0
          for lib_info in "${LIBS[@]}"; do
            lib="${lib_info%%:*}"
            desc="${lib_info#*:}"
            
            if [[ -f "lib/$lib" ]]; then
              LINES=$(wc -l < "lib/$lib")
              echo "[OK] lib/$lib - $desc ($LINES lines)" >> "$STRUCT_LOG"
            else
              echo "[MISSING] lib/$lib - $desc" >> "$STRUCT_LOG"
              MISSING_LIBS=$((MISSING_LIBS + 1))
            fi
          done
          
          echo "" >> "$STRUCT_LOG"
          echo "Missing libraries: $MISSING_LIBS" >> "$STRUCT_LOG"
          
          # Full tree
          echo "" >> "$STRUCT_LOG"
          echo "─── Complete Directory Tree ───" >> "$STRUCT_LOG"
          echo "" >> "$STRUCT_LOG"
          
          tree -a -I '.git' --noreport . >> "$STRUCT_LOG" 2>/dev/null || find . -not -path './.git/*' | sort >> "$STRUCT_LOG"
          
          cat "$STRUCT_LOG"

      - name: Upload Structure Logs
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: structure-validation-${{ needs.init-environment.outputs.run_id }}
          path: logs/structure/
          retention-days: 30

  ################################################################################
  # JOB 5: Library Loading Tests
  ################################################################################
  library-tests:
    name: "5. Library Loading Tests"
    runs-on: ubuntu-latest
    needs: [init-environment, syntax-analysis]
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Create Log Structure
        run: |
          mkdir -p logs/library/{individual,functions,dependencies}
          echo "Run ID: ${{ needs.init-environment.outputs.run_id }}" > logs/library/run_info.txt

      - name: Install Dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y jq bc parallel

      - name: Deep Library Loading Analysis
        run: |
          echo "══════════════════════════════════════════════════════════════════════════════"
          echo "DEEP LIBRARY LOADING ANALYSIS"
          echo "══════════════════════════════════════════════════════════════════════════════"
          
          LIB_REPORT="logs/library/full_library_report.log"
          FUNC_REPORT="logs/library/functions/all_functions.log"
          DEP_REPORT="logs/library/dependencies/dependency_map.log"
          
          cat << 'HEADER' > "$LIB_REPORT"
          ══════════════════════════════════════════════════════════════════════════════
          NEKO LIBRARY LOADING ANALYSIS
          ══════════════════════════════════════════════════════════════════════════════
          
          This report shows detailed analysis of each library file including:
          - Load success/failure
          - Functions defined
          - Variables exported
          - Dependencies
          - Error messages
          
          HEADER
          
          echo "Timestamp: $(date '+%Y-%m-%d %H:%M:%S.%3N')" >> "$LIB_REPORT"
          echo "" >> "$LIB_REPORT"
          
          # Set up test environment
          export SCRIPTPATH="$(pwd)"
          export LIB_PATH="$(pwd)/lib"
          export MODULES_PATH="$(pwd)/modules"
          export CONFIG_PATH="$(pwd)/config"
          export TOOLS_PATH="/tmp/Tools"
          export dir="/tmp/neko_test_$$"
          export called_fn_dir="${dir}/.called"
          export LOGFILE="${dir}/test.log"
          export domain="test.example.com"
          export DEBUG="true"
          
          mkdir -p "$dir"/{logs,.called}
          mkdir -p "$TOOLS_PATH"
          touch "$LOGFILE"
          
          # Load config first
          echo "─── Loading Configuration ───" >> "$LIB_REPORT"
          if source neko.cfg 2>&1 | tee -a "$LIB_REPORT"; then
            echo "[OK] Configuration loaded" >> "$LIB_REPORT"
          else
            echo "[WARN] Configuration had issues" >> "$LIB_REPORT"
          fi
          
          echo "" >> "$LIB_REPORT"
          
          # Libraries in load order
          LIBRARIES=(
            "core.sh"
            "logging.sh"
            "error_handling.sh"
            "error_reporting.sh"
            "parallel.sh"
            "async_pipeline.sh"
            "queue_manager.sh"
            "data_flow_bus.sh"
            "orchestrator.sh"
            "proxy_rotation.sh"
            "intelligence.sh"
            "plugin.sh"
            "discord_notifications.sh"
          )
          
          LOAD_SUCCESS=0
          LOAD_FAIL=0
          TOTAL_FUNCTIONS=0
          
          for lib in "${LIBRARIES[@]}"; do
            LIB_FILE="lib/$lib"
            LIB_NAME="${lib%.sh}"
            INDIVIDUAL_LOG="logs/library/individual/${LIB_NAME}_analysis.log"
            
            echo "" >> "$LIB_REPORT"
            echo "════════════════════════════════════════════════════════════════" >> "$LIB_REPORT"
            echo "LIBRARY: $lib" >> "$LIB_REPORT"
            echo "════════════════════════════════════════════════════════════════" >> "$LIB_REPORT"
            
            cat << LIBHEADER > "$INDIVIDUAL_LOG"
          ══════════════════════════════════════════════════════════════════════════════
          LIBRARY ANALYSIS: $lib
          ══════════════════════════════════════════════════════════════════════════════
          
          LIBHEADER
            
            if [[ ! -f "$LIB_FILE" ]]; then
              echo "[SKIP] File not found: $LIB_FILE" >> "$LIB_REPORT"
              echo "Status: FILE NOT FOUND" >> "$INDIVIDUAL_LOG"
              continue
            fi
            
            # File info
            echo "" >> "$LIB_REPORT"
            echo "─── File Information ───" >> "$LIB_REPORT"
            echo "  Path:  $LIB_FILE" >> "$LIB_REPORT"
            echo "  Size:  $(wc -c < "$LIB_FILE") bytes" >> "$LIB_REPORT"
            echo "  Lines: $(wc -l < "$LIB_FILE")" >> "$LIB_REPORT"
            
            # Get functions before loading
            FUNCS_BEFORE=$(declare -F 2>/dev/null | wc -l)
            
            echo "" >> "$LIB_REPORT"
            echo "─── Loading Library ───" >> "$LIB_REPORT"
            
            # Try to source
            if source "$LIB_FILE" 2>&1 | tee -a "$LIB_REPORT" "$INDIVIDUAL_LOG"; then
              echo "[PASS] Library loaded successfully" >> "$LIB_REPORT"
              echo "Status: LOADED" >> "$INDIVIDUAL_LOG"
              LOAD_SUCCESS=$((LOAD_SUCCESS + 1))
            else
              echo "[FAIL] Library failed to load" >> "$LIB_REPORT"
              echo "Status: FAILED" >> "$INDIVIDUAL_LOG"
              LOAD_FAIL=$((LOAD_FAIL + 1))
            fi
            
            # Get functions after loading
            FUNCS_AFTER=$(declare -F 2>/dev/null | wc -l)
            NEW_FUNCS=$((FUNCS_AFTER - FUNCS_BEFORE))
            TOTAL_FUNCTIONS=$((TOTAL_FUNCTIONS + NEW_FUNCS))
            
            echo "" >> "$LIB_REPORT"
            echo "─── Functions Defined ───" >> "$LIB_REPORT"
            echo "  New functions added: $NEW_FUNCS" >> "$LIB_REPORT"
            
            # List functions from this library
            echo "" >> "$LIB_REPORT"
            echo "  Functions:" >> "$LIB_REPORT"
            grep -E '^\s*(function\s+)?[a-zA-Z_][a-zA-Z0-9_]*\s*\(\)' "$LIB_FILE" 2>/dev/null | \
              sed 's/().*$//' | sed 's/function //' | sed 's/^[[:space:]]*/    /' >> "$LIB_REPORT" || \
              echo "    (none extracted)" >> "$LIB_REPORT"
            
            # Check for dependencies (source statements)
            echo "" >> "$LIB_REPORT"
            echo "─── Dependencies ───" >> "$LIB_REPORT"
            
            DEPS=$(grep -E '^\s*(source|\.)\s+' "$LIB_FILE" 2>/dev/null)
            if [[ -n "$DEPS" ]]; then
              echo "$DEPS" | sed 's/^/    /' >> "$LIB_REPORT"
            else
              echo "    No explicit dependencies" >> "$LIB_REPORT"
            fi
            
            # Check for global variables
            echo "" >> "$LIB_REPORT"
            echo "─── Global Variables ───" >> "$LIB_REPORT"
            
            grep -E '^\s*(declare -g|export)\s+' "$LIB_FILE" 2>/dev/null | head -10 | sed 's/^/    /' >> "$LIB_REPORT" || \
              echo "    (none found)" >> "$LIB_REPORT"
            
          done
          
          # Summary
          cat << EOF >> "$LIB_REPORT"
          
          ══════════════════════════════════════════════════════════════════════════════
          LIBRARY LOADING SUMMARY
          ══════════════════════════════════════════════════════════════════════════════
          
          Total Libraries:      ${#LIBRARIES[@]}
          Successfully Loaded:  $LOAD_SUCCESS
          Failed to Load:       $LOAD_FAIL
          Total Functions:      $TOTAL_FUNCTIONS
          
          ══════════════════════════════════════════════════════════════════════════════
          EOF
          
          # All functions report
          echo "All defined functions after loading libraries:" > "$FUNC_REPORT"
          echo "" >> "$FUNC_REPORT"
          declare -F | sed 's/declare -f //' >> "$FUNC_REPORT"
          
          # Cleanup
          rm -rf "$dir"
          
          cat "$LIB_REPORT"
          
          if [[ $LOAD_FAIL -gt 0 ]]; then
            echo ""
            echo "[ERROR] $LOAD_FAIL libraries failed to load"
            exit 1
          fi

      - name: Test Core Functions
        run: |
          echo "══════════════════════════════════════════════════════════════════════════════"
          echo "CORE FUNCTION TESTING"
          echo "══════════════════════════════════════════════════════════════════════════════"
          
          FUNC_TEST_LOG="logs/library/functions/core_function_tests.log"
          
          cat << 'HEADER' > "$FUNC_TEST_LOG"
          ══════════════════════════════════════════════════════════════════════════════
          CORE FUNCTION TESTS
          ══════════════════════════════════════════════════════════════════════════════
          
          Testing core utility functions for correct behavior.
          
          HEADER
          
          # Setup
          export SCRIPTPATH="$(pwd)"
          export dir="/tmp/neko_test_$$"
          export LOGFILE="${dir}/test.log"
          export TOOLS_PATH="/tmp/Tools"
          export called_fn_dir="${dir}/.called"
          mkdir -p "$dir"/.called "$TOOLS_PATH"
          touch "$LOGFILE"
          
          source neko.cfg 2>/dev/null || true
          source lib/core.sh 2>/dev/null || true
          
          TESTS_PASSED=0
          TESTS_FAILED=0
          
          run_test() {
            local name="$1"
            local result="$2"
            local expected="$3"
            
            echo "" >> "$FUNC_TEST_LOG"
            echo "─── Test: $name ───" >> "$FUNC_TEST_LOG"
            
            if [[ "$result" == "$expected" ]]; then
              echo "  Result: PASS" >> "$FUNC_TEST_LOG"
              echo "  Expected: $expected" >> "$FUNC_TEST_LOG"
              echo "  Got:      $result" >> "$FUNC_TEST_LOG"
              TESTS_PASSED=$((TESTS_PASSED + 1))
              echo "[PASS] $name"
            else
              echo "  Result: FAIL" >> "$FUNC_TEST_LOG"
              echo "  Expected: $expected" >> "$FUNC_TEST_LOG"
              echo "  Got:      $result" >> "$FUNC_TEST_LOG"
              TESTS_FAILED=$((TESTS_FAILED + 1))
              echo "[FAIL] $name"
            fi
          }
          
          # Test command_exists
          if type -t command_exists &>/dev/null; then
            if command_exists bash; then
              run_test "command_exists(bash)" "true" "true"
            else
              run_test "command_exists(bash)" "false" "true"
            fi
            
            if command_exists nonexistent_command_xyz; then
              run_test "command_exists(nonexistent)" "true" "false"
            else
              run_test "command_exists(nonexistent)" "false" "false"
            fi
          else
            echo "[SKIP] command_exists not defined" | tee -a "$FUNC_TEST_LOG"
          fi
          
          # Test validate_domain
          if type -t validate_domain &>/dev/null; then
            if validate_domain "example.com"; then
              run_test "validate_domain(example.com)" "valid" "valid"
            else
              run_test "validate_domain(example.com)" "invalid" "valid"
            fi
            
            if validate_domain "192.168.1.1"; then
              run_test "validate_domain(192.168.1.1)" "valid" "valid"
            else
              run_test "validate_domain(192.168.1.1)" "invalid" "valid"
            fi
            
            if validate_domain "invalid domain"; then
              run_test "validate_domain(invalid domain)" "valid" "invalid"
            else
              run_test "validate_domain(invalid domain)" "invalid" "invalid"
            fi
          else
            echo "[SKIP] validate_domain not defined" | tee -a "$FUNC_TEST_LOG"
          fi
          
          # Test is_ip
          if type -t is_ip &>/dev/null; then
            if is_ip "192.168.1.1"; then
              run_test "is_ip(192.168.1.1)" "true" "true"
            else
              run_test "is_ip(192.168.1.1)" "false" "true"
            fi
            
            if is_ip "example.com"; then
              run_test "is_ip(example.com)" "true" "false"
            else
              run_test "is_ip(example.com)" "false" "false"
            fi
          else
            echo "[SKIP] is_ip not defined" | tee -a "$FUNC_TEST_LOG"
          fi
          
          # Test ensure_dir
          if type -t ensure_dir &>/dev/null; then
            TEST_DIR="/tmp/neko_ensure_dir_test_$$"
            ensure_dir "$TEST_DIR"
            if [[ -d "$TEST_DIR" ]]; then
              run_test "ensure_dir(creates dir)" "created" "created"
              rmdir "$TEST_DIR"
            else
              run_test "ensure_dir(creates dir)" "not_created" "created"
            fi
          else
            echo "[SKIP] ensure_dir not defined" | tee -a "$FUNC_TEST_LOG"
          fi
          
          # Test timestamp
          if type -t timestamp &>/dev/null; then
            TS=$(timestamp)
            if [[ "$TS" =~ ^[0-9]{8}_[0-9]{6}$ ]]; then
              run_test "timestamp(format)" "correct" "correct"
            else
              run_test "timestamp(format)" "incorrect:$TS" "correct"
            fi
          else
            echo "[SKIP] timestamp not defined" | tee -a "$FUNC_TEST_LOG"
          fi
          
          # Test count_lines
          if type -t count_lines &>/dev/null; then
            echo -e "line1\nline2\nline3" > /tmp/count_test_$$
            COUNT=$(count_lines /tmp/count_test_$$)
            rm -f /tmp/count_test_$$
            run_test "count_lines(3 lines)" "$COUNT" "3"
          else
            echo "[SKIP] count_lines not defined" | tee -a "$FUNC_TEST_LOG"
          fi
          
          # Summary
          cat << EOF >> "$FUNC_TEST_LOG"
          
          ══════════════════════════════════════════════════════════════════════════════
          FUNCTION TEST SUMMARY
          ══════════════════════════════════════════════════════════════════════════════
          
          Tests Passed: $TESTS_PASSED
          Tests Failed: $TESTS_FAILED
          
          ══════════════════════════════════════════════════════════════════════════════
          EOF
          
          # Cleanup
          rm -rf "$dir"
          
          cat "$FUNC_TEST_LOG"

      - name: Upload Library Logs
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: library-tests-${{ needs.init-environment.outputs.run_id }}
          path: logs/library/
          retention-days: 30

  ################################################################################
  # JOB 6: Module Loading Tests
  ################################################################################
  module-tests:
    name: "6. Module Loading Tests"
    runs-on: ubuntu-latest
    needs: [init-environment, library-tests]
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Create Log Structure
        run: |
          mkdir -p logs/module/{individual,functions}
          echo "Run ID: ${{ needs.init-environment.outputs.run_id }}" > logs/module/run_info.txt

      - name: Install Dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y jq bc parallel

      - name: Deep Module Loading Analysis
        run: |
          echo "══════════════════════════════════════════════════════════════════════════════"
          echo "DEEP MODULE LOADING ANALYSIS"
          echo "══════════════════════════════════════════════════════════════════════════════"
          
          MOD_REPORT="logs/module/full_module_report.log"
          FUNC_MAP="logs/module/functions/function_map.log"
          
          cat << 'HEADER' > "$MOD_REPORT"
          ══════════════════════════════════════════════════════════════════════════════
          NEKO MODULE LOADING ANALYSIS
          ══════════════════════════════════════════════════════════════════════════════
          
          This report analyzes each scanning module including:
          - Load success/failure
          - Main function availability
          - Sub-functions defined
          - Tool dependencies
          
          HEADER
          
          echo "Timestamp: $(date '+%Y-%m-%d %H:%M:%S.%3N')" >> "$MOD_REPORT"
          echo "" >> "$MOD_REPORT"
          
          # Setup environment
          export SCRIPTPATH="$(pwd)"
          export LIB_PATH="$(pwd)/lib"
          export MODULES_PATH="$(pwd)/modules"
          export CONFIG_PATH="$(pwd)/config"
          export TOOLS_PATH="/tmp/Tools"
          export dir="/tmp/neko_test_$$"
          export called_fn_dir="${dir}/.called"
          export LOGFILE="${dir}/test.log"
          export domain="test.example.com"
          export DEBUG="true"
          
          mkdir -p "$dir"/{logs,.called,.tmp,osint,subdomains,dns,hosts,webs,ports,content,technologies,urls,js,parameters,vulnerabilities,xss,takeover,cloud,auth,api,reports}
          mkdir -p "$TOOLS_PATH"
          touch "$LOGFILE"
          
          # Load prerequisites
          echo "─── Loading Prerequisites ───" >> "$MOD_REPORT"
          source neko.cfg 2>/dev/null || true
          for lib in lib/*.sh; do
            source "$lib" 2>/dev/null || true
          done
          echo "Prerequisites loaded" >> "$MOD_REPORT"
          echo "" >> "$MOD_REPORT"
          
          # Module definitions with expected main functions
          declare -A MODULE_FUNCS=(
            ["00_osint.sh"]="osint_main"
            ["01_subdomain.sh"]="subdomain_main"
            ["02_dns.sh"]="dns_main"
            ["03_webprobe.sh"]="webprobe_main"
            ["04_portscan.sh"]="portscan_main"
            ["05_content.sh"]="content_main"
            ["06_fingerprint.sh"]="fingerprint_main"
            ["07_urlanalysis.sh"]="urlanalysis_main"
            ["08_params.sh"]="param_main"
            ["09_vulnscan.sh"]="vulnscan_main"
            ["10_xss.sh"]="xss_main"
            ["11_takeover.sh"]="takeover_main"
            ["12_cloud.sh"]="cloud_main"
            ["13_auth.sh"]="auth_main"
            ["14_api.sh"]="api_main"
            ["15_report.sh"]="report_main"
            ["16_advanced_vulns.sh"]="advanced_vulns_main"
            ["17_bettercap.sh"]="bettercap_main"
          )
          
          LOAD_SUCCESS=0
          LOAD_FAIL=0
          FUNC_FOUND=0
          FUNC_MISSING=0
          
          echo "Module Name|Expected Function|Load Status|Function Status" > "$FUNC_MAP"
          echo "-----------|-----------------|-----------|---------------" >> "$FUNC_MAP"
          
          for module in modules/*.sh; do
            MOD_NAME=$(basename "$module")
            MOD_BASE="${MOD_NAME%.sh}"
            INDIVIDUAL_LOG="logs/module/individual/${MOD_BASE}_analysis.log"
            
            echo "" >> "$MOD_REPORT"
            echo "════════════════════════════════════════════════════════════════" >> "$MOD_REPORT"
            echo "MODULE: $MOD_NAME" >> "$MOD_REPORT"
            echo "════════════════════════════════════════════════════════════════" >> "$MOD_REPORT"
            
            cat << MODHEADER > "$INDIVIDUAL_LOG"
          ══════════════════════════════════════════════════════════════════════════════
          MODULE ANALYSIS: $MOD_NAME
          ══════════════════════════════════════════════════════════════════════════════
          
          MODHEADER
            
            # File info
            echo "" >> "$MOD_REPORT"
            echo "─── File Information ───" >> "$MOD_REPORT"
            echo "  Path:  $module" >> "$MOD_REPORT"
            echo "  Size:  $(wc -c < "$module") bytes" >> "$MOD_REPORT"
            echo "  Lines: $(wc -l < "$module")" >> "$MOD_REPORT"
            
            LOAD_STATUS="UNKNOWN"
            FUNC_STATUS="UNKNOWN"
            EXPECTED_FUNC="${MODULE_FUNCS[$MOD_NAME]:-unknown}"
            
            echo "" >> "$MOD_REPORT"
            echo "─── Loading Module ───" >> "$MOD_REPORT"
            
            # Try to source
            if source "$module" 2>&1 | tee -a "$MOD_REPORT" "$INDIVIDUAL_LOG"; then
              echo "[PASS] Module loaded successfully" >> "$MOD_REPORT"
              LOAD_STATUS="LOADED"
              LOAD_SUCCESS=$((LOAD_SUCCESS + 1))
            else
              echo "[FAIL] Module failed to load" >> "$MOD_REPORT"
              LOAD_STATUS="FAILED"
              LOAD_FAIL=$((LOAD_FAIL + 1))
            fi
            
            echo "" >> "$MOD_REPORT"
            echo "─── Main Function Check ───" >> "$MOD_REPORT"
            echo "  Expected function: $EXPECTED_FUNC" >> "$MOD_REPORT"
            
            if [[ "$EXPECTED_FUNC" != "unknown" ]]; then
              if type -t "$EXPECTED_FUNC" &>/dev/null; then
                echo "  [FOUND] $EXPECTED_FUNC is available" >> "$MOD_REPORT"
                FUNC_STATUS="FOUND"
                FUNC_FOUND=$((FUNC_FOUND + 1))
              else
                echo "  [MISSING] $EXPECTED_FUNC is NOT defined" >> "$MOD_REPORT"
                FUNC_STATUS="MISSING"
                FUNC_MISSING=$((FUNC_MISSING + 1))
              fi
            fi
            
            echo "" >> "$MOD_REPORT"
            echo "─── All Functions in Module ───" >> "$MOD_REPORT"
            
            grep -E '^\s*(function\s+)?[a-zA-Z_][a-zA-Z0-9_]*\s*\(\)' "$module" 2>/dev/null | \
              sed 's/().*$//' | sed 's/function //' | sed 's/^[[:space:]]*/    /' >> "$MOD_REPORT" || \
              echo "    (none extracted)" >> "$MOD_REPORT"
            
            echo "" >> "$MOD_REPORT"
            echo "─── Tool Dependencies ───" >> "$MOD_REPORT"
            
            # Find tool checks in the module
            grep -E 'command_exists|command -v|which ' "$module" 2>/dev/null | head -10 | sed 's/^/    /' >> "$MOD_REPORT" || \
              echo "    (none found)" >> "$MOD_REPORT"
            
            # Update function map
            echo "$MOD_NAME|$EXPECTED_FUNC|$LOAD_STATUS|$FUNC_STATUS" >> "$FUNC_MAP"
            
          done
          
          # Summary
          cat << EOF >> "$MOD_REPORT"
          
          ══════════════════════════════════════════════════════════════════════════════
          MODULE LOADING SUMMARY
          ══════════════════════════════════════════════════════════════════════════════
          
          Total Modules:            $(ls modules/*.sh 2>/dev/null | wc -l)
          Successfully Loaded:      $LOAD_SUCCESS
          Failed to Load:           $LOAD_FAIL
          Main Functions Found:     $FUNC_FOUND
          Main Functions Missing:   $FUNC_MISSING
          
          ══════════════════════════════════════════════════════════════════════════════
          EOF
          
          # Cleanup
          rm -rf "$dir"
          
          cat "$MOD_REPORT"
          
          echo ""
          echo "=== Function Availability Map ==="
          cat "$FUNC_MAP"
          
          if [[ $LOAD_FAIL -gt 0 ]]; then
            echo ""
            echo "[ERROR] $LOAD_FAIL modules failed to load"
            exit 1
          fi

      - name: Upload Module Logs
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: module-tests-${{ needs.init-environment.outputs.run_id }}
          path: logs/module/
          retention-days: 30

  ################################################################################
  # JOB 7: Main Script Tests
  ################################################################################
  main-script-tests:
    name: "7. Main Script Tests"
    runs-on: ubuntu-latest
    needs: [init-environment, module-tests]
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Create Log Structure
        run: |
          mkdir -p logs/main/{commands,arguments,integration}
          echo "Run ID: ${{ needs.init-environment.outputs.run_id }}" > logs/main/run_info.txt

      - name: Make Scripts Executable
        run: |
          chmod +x neko.sh install.sh run_tests.sh
          chmod +x modules/*.sh lib/*.sh 2>/dev/null || true

      - name: Test All Command Line Options
        run: |
          echo "══════════════════════════════════════════════════════════════════════════════"
          echo "COMMAND LINE OPTIONS TESTING"
          echo "══════════════════════════════════════════════════════════════════════════════"
          
          CMD_LOG="logs/main/commands/command_tests.log"
          
          cat << 'HEADER' > "$CMD_LOG"
          ══════════════════════════════════════════════════════════════════════════════
          COMMAND LINE OPTIONS TEST REPORT
          ══════════════════════════════════════════════════════════════════════════════
          
          HEADER
          
          echo "Timestamp: $(date '+%Y-%m-%d %H:%M:%S.%3N')" >> "$CMD_LOG"
          echo "" >> "$CMD_LOG"
          
          # Test --help
          echo "─── Testing --help ───" >> "$CMD_LOG"
          ./neko.sh --help > logs/main/commands/help_output.txt 2>&1 || true
          
          if grep -qE "(Usage|USAGE|usage)" logs/main/commands/help_output.txt; then
            echo "[PASS] --help shows usage" >> "$CMD_LOG"
          else
            echo "[WARN] --help may not show proper usage" >> "$CMD_LOG"
          fi
          cat logs/main/commands/help_output.txt >> "$CMD_LOG"
          
          # Test --version
          echo "" >> "$CMD_LOG"
          echo "─── Testing --version ───" >> "$CMD_LOG"
          ./neko.sh --version > logs/main/commands/version_output.txt 2>&1 || true
          cat logs/main/commands/version_output.txt >> "$CMD_LOG"
          
          # Test --check-tools
          echo "" >> "$CMD_LOG"
          echo "─── Testing --check-tools ───" >> "$CMD_LOG"
          ./neko.sh --check-tools > logs/main/commands/check_tools_output.txt 2>&1 || true
          head -50 logs/main/commands/check_tools_output.txt >> "$CMD_LOG"
          
          # Test missing domain
          echo "" >> "$CMD_LOG"
          echo "─── Testing no arguments ───" >> "$CMD_LOG"
          if ./neko.sh > logs/main/commands/no_args.txt 2>&1; then
            echo "[WARN] Should require domain" >> "$CMD_LOG"
          else
            echo "[PASS] Correctly requires domain" >> "$CMD_LOG"
          fi
          cat logs/main/commands/no_args.txt >> "$CMD_LOG"
          
          # Test invalid option
          echo "" >> "$CMD_LOG"
          echo "─── Testing invalid option ───" >> "$CMD_LOG"
          if ./neko.sh --invalid-xyz > logs/main/commands/invalid_opt.txt 2>&1; then
            echo "[WARN] Should reject invalid option" >> "$CMD_LOG"
          else
            echo "[PASS] Correctly rejects invalid option" >> "$CMD_LOG"
          fi
          cat logs/main/commands/invalid_opt.txt >> "$CMD_LOG"
          
          cat "$CMD_LOG"

      - name: Upload Main Script Logs
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: main-script-tests-${{ needs.init-environment.outputs.run_id }}
          path: logs/main/
          retention-days: 30

  ################################################################################
  # JOB 8: Installation Simulation
  ################################################################################
  installation-tests:
    name: "8. Installation Tests"
    runs-on: ubuntu-latest
    needs: [init-environment, main-script-tests]
    if: ${{ github.event.inputs.test_installation != 'false' }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Create Log Structure
        run: |
          mkdir -p logs/install/{system,go_tools,python_tools,verification}
          echo "Run ID: ${{ needs.init-environment.outputs.run_id }}" > logs/install/run_info.txt

      - name: System Package Installation
        run: |
          echo "══════════════════════════════════════════════════════════════════════════════"
          echo "SYSTEM PACKAGE INSTALLATION"
          echo "══════════════════════════════════════════════════════════════════════════════"
          
          INSTALL_LOG="logs/install/system/system_packages.log"
          
          cat << 'HEADER' > "$INSTALL_LOG"
          ══════════════════════════════════════════════════════════════════════════════
          SYSTEM PACKAGE INSTALLATION LOG
          ══════════════════════════════════════════════════════════════════════════════
          
          HEADER
          
          echo "Timestamp: $(date '+%Y-%m-%d %H:%M:%S.%3N')" >> "$INSTALL_LOG"
          echo "" >> "$INSTALL_LOG"
          
          echo "─── Updating Package List ───" >> "$INSTALL_LOG"
          sudo apt-get update 2>&1 | tee -a "$INSTALL_LOG"
          
          echo "" >> "$INSTALL_LOG"
          echo "─── Installing Packages ───" >> "$INSTALL_LOG"
          
          PACKAGES=(
            "curl"
            "wget"
            "git"
            "jq"
            "python3"
            "python3-pip"
            "python3-venv"
            "build-essential"
            "libpcap-dev"
            "libssl-dev"
            "nmap"
            "whois"
            "dnsutils"
            "bc"
            "netcat-openbsd"
            "parallel"
            "sqlite3"
          )
          
          for pkg in "${PACKAGES[@]}"; do
            echo "" >> "$INSTALL_LOG"
            echo "Installing: $pkg" >> "$INSTALL_LOG"
            if sudo apt-get install -y "$pkg" 2>&1 | tail -5 >> "$INSTALL_LOG"; then
              echo "[OK] $pkg installed" >> "$INSTALL_LOG"
            else
              echo "[WARN] $pkg may have issues" >> "$INSTALL_LOG"
            fi
          done
          
          tail -100 "$INSTALL_LOG"

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.21'

      - name: Install Go Tools
        run: |
          echo "══════════════════════════════════════════════════════════════════════════════"
          echo "GO TOOLS INSTALLATION"
          echo "══════════════════════════════════════════════════════════════════════════════"
          
          GO_LOG="logs/install/go_tools/go_tools_install.log"
          
          cat << 'HEADER' > "$GO_LOG"
          ══════════════════════════════════════════════════════════════════════════════
          GO TOOLS INSTALLATION LOG
          ══════════════════════════════════════════════════════════════════════════════
          
          HEADER
          
          echo "Timestamp: $(date '+%Y-%m-%d %H:%M:%S.%3N')" >> "$GO_LOG"
          echo "Go Version: $(go version)" >> "$GO_LOG"
          echo "GOPATH: $(go env GOPATH)" >> "$GO_LOG"
          echo "" >> "$GO_LOG"
          
          GO_TOOLS=(
            "github.com/projectdiscovery/subfinder/v2/cmd/subfinder@latest"
            "github.com/projectdiscovery/httpx/cmd/httpx@latest"
            "github.com/projectdiscovery/nuclei/v3/cmd/nuclei@latest"
            "github.com/projectdiscovery/dnsx/cmd/dnsx@latest"
            "github.com/projectdiscovery/katana/cmd/katana@latest"
            "github.com/tomnomnom/anew@latest"
            "github.com/tomnomnom/unfurl@latest"
            "github.com/ffuf/ffuf/v2@latest"
          )
          
          INSTALLED=0
          FAILED=0
          
          for tool in "${GO_TOOLS[@]}"; do
            TOOL_NAME=$(basename "${tool%@*}")
            echo "" >> "$GO_LOG"
            echo "─── Installing: $TOOL_NAME ───" >> "$GO_LOG"
            
            START_TIME=$(date +%s)
            
            if go install "$tool" 2>&1 | tee -a "$GO_LOG"; then
              END_TIME=$(date +%s)
              DURATION=$((END_TIME - START_TIME))
              echo "[OK] $TOOL_NAME installed in ${DURATION}s" | tee -a "$GO_LOG"
              INSTALLED=$((INSTALLED + 1))
            else
              echo "[FAIL] $TOOL_NAME installation failed" | tee -a "$GO_LOG"
              FAILED=$((FAILED + 1))
            fi
          done
          
          echo "" >> "$GO_LOG"
          echo "═══════════════════════════════════════════════════════════════" >> "$GO_LOG"
          echo "GO TOOLS SUMMARY" >> "$GO_LOG"
          echo "═══════════════════════════════════════════════════════════════" >> "$GO_LOG"
          echo "Installed: $INSTALLED" >> "$GO_LOG"
          echo "Failed: $FAILED" >> "$GO_LOG"
          
          # Verify tools
          echo "" >> "$GO_LOG"
          echo "─── Verification ───" >> "$GO_LOG"
          
          export PATH="$PATH:$(go env GOPATH)/bin"
          
          for tool in "${GO_TOOLS[@]}"; do
            TOOL_NAME=$(basename "${tool%@*}")
            if command -v "$TOOL_NAME" &>/dev/null; then
              VERSION=$($TOOL_NAME --version 2>&1 | head -1 || echo "version unknown")
              echo "[OK] $TOOL_NAME: $VERSION" >> "$GO_LOG"
            else
              echo "[MISSING] $TOOL_NAME not in PATH" >> "$GO_LOG"
            fi
          done
          
          cat "$GO_LOG"

      - name: Upload Installation Logs
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: installation-tests-${{ needs.init-environment.outputs.run_id }}
          path: logs/install/
          retention-days: 30

  ################################################################################
  # JOB 9: Run Test Suite
  ################################################################################
  run-test-suite:
    name: "9. Run Test Suite"
    runs-on: ubuntu-latest
    needs: [init-environment, module-tests]
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Create Log Structure
        run: |
          mkdir -p logs/testsuite
          echo "Run ID: ${{ needs.init-environment.outputs.run_id }}" > logs/testsuite/run_info.txt

      - name: Install Dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y jq bc parallel

      - name: Run Neko Test Suite
        run: |
          echo "══════════════════════════════════════════════════════════════════════════════"
          echo "RUNNING NEKO TEST SUITE"
          echo "══════════════════════════════════════════════════════════════════════════════"
          
          chmod +x run_tests.sh
          
          # Run test suite
          ./run_tests.sh 2>&1 | tee logs/testsuite/test_output.log || true
          
          # Copy any generated test logs
          if [[ -d "test_logs" ]]; then
            cp -r test_logs/* logs/testsuite/ 2>/dev/null || true
          fi

      - name: Upload Test Suite Logs
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: testsuite-logs-${{ needs.init-environment.outputs.run_id }}
          path: logs/testsuite/
          retention-days: 30

  ################################################################################
  # JOB 10: Final Summary
  ################################################################################
  final-summary:
    name: "10. Final Summary"
    runs-on: ubuntu-latest
    needs: [
      init-environment,
      syntax-analysis,
      config-validation,
      structure-validation,
      library-tests,
      module-tests,
      main-script-tests,
      run-test-suite
    ]
    if: always()
    steps:
      - name: Download All Artifacts
        uses: actions/download-artifact@v4
        with:
          path: all-logs

      - name: Create Master Summary
        run: |
          echo "══════════════════════════════════════════════════════════════════════════════"
          echo "NEKO COMPREHENSIVE TESTING - FINAL SUMMARY"
          echo "══════════════════════════════════════════════════════════════════════════════"
          
          SUMMARY_FILE="all-logs/MASTER_SUMMARY.md"
          
          cat << EOF > "$SUMMARY_FILE"
          # Neko Comprehensive Testing - Master Summary
          
          **Run ID:** ${{ needs.init-environment.outputs.run_id }}
          **Timestamp:** $(date '+%Y-%m-%d %H:%M:%S')
          **Git SHA:** ${{ github.sha }}
          **Branch:** ${{ github.ref }}
          
          ## Job Results
          
          | Job | Status |
          |-----|--------|
          | 1. Initialize Environment | ${{ needs.init-environment.result }} |
          | 2. Syntax Analysis | ${{ needs.syntax-analysis.result }} |
          | 3. Config Validation | ${{ needs.config-validation.result }} |
          | 4. Structure Validation | ${{ needs.structure-validation.result }} |
          | 5. Library Tests | ${{ needs.library-tests.result }} |
          | 6. Module Tests | ${{ needs.module-tests.result }} |
          | 7. Main Script Tests | ${{ needs.main-script-tests.result }} |
          | 8. Test Suite | ${{ needs.run-test-suite.result }} |
          
          ## Overall Status
          
          EOF
          
          # Determine overall status
          OVERALL="SUCCESS"
          CRITICAL_FAILURES=""
          
          if [[ "${{ needs.syntax-analysis.result }}" == "failure" ]]; then
            OVERALL="FAILURE"
            CRITICAL_FAILURES+="- Syntax Analysis FAILED\n"
          fi
          
          if [[ "${{ needs.config-validation.result }}" == "failure" ]]; then
            OVERALL="FAILURE"
            CRITICAL_FAILURES+="- Configuration Validation FAILED\n"
          fi
          
          if [[ "${{ needs.library-tests.result }}" == "failure" ]]; then
            OVERALL="FAILURE"
            CRITICAL_FAILURES+="- Library Tests FAILED\n"
          fi
          
          if [[ "${{ needs.module-tests.result }}" == "failure" ]]; then
            OVERALL="FAILURE"
            CRITICAL_FAILURES+="- Module Tests FAILED\n"
          fi
          
          echo "**Overall: $OVERALL**" >> "$SUMMARY_FILE"
          echo "" >> "$SUMMARY_FILE"
          
          if [[ -n "$CRITICAL_FAILURES" ]]; then
            echo "### Critical Failures" >> "$SUMMARY_FILE"
            echo "" >> "$SUMMARY_FILE"
            printf "$CRITICAL_FAILURES" >> "$SUMMARY_FILE"
            echo "" >> "$SUMMARY_FILE"
          fi
          
          echo "## Artifacts" >> "$SUMMARY_FILE"
          echo "" >> "$SUMMARY_FILE"
          echo "All detailed logs are available as downloadable artifacts." >> "$SUMMARY_FILE"
          echo "" >> "$SUMMARY_FILE"
          
          # List available artifacts
          echo "### Available Logs" >> "$SUMMARY_FILE"
          echo "" >> "$SUMMARY_FILE"
          ls -la all-logs/ >> "$SUMMARY_FILE" 2>/dev/null || echo "No artifacts found" >> "$SUMMARY_FILE"
          
          cat "$SUMMARY_FILE"
          
          echo ""
          echo "══════════════════════════════════════════════════════════════════════════════"
          
          if [[ "$OVERALL" == "FAILURE" ]]; then
            echo ""
            echo "[CRITICAL] Some tests failed. Please review the logs."
            exit 1
          fi

      - name: Upload Master Summary
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: master-summary-${{ needs.init-environment.outputs.run_id }}
          path: all-logs/MASTER_SUMMARY.md
          retention-days: 30
