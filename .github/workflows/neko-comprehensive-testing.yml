################################################################################
# NEKO COMPREHENSIVE TESTING WORKFLOW
# ============================================================================
# This is the master testing workflow for the Neko Bug Bounty Automation
# Framework. It combines 25 different testing scenarios into a single
# comprehensive test suite:
#
# 1.  Integration Testing - End-to-end scan flow testing
# 2.  Library Dependency Chain Testing - Library loading order
# 3.  Module Function Coverage - Individual function testing
# 4.  Configuration Validation Suite - Config option testing
# 5.  Tool Availability Mock Testing - Fallback mechanisms
# 6.  Error Handling and Recovery - Error path testing
# 7.  Parallel Processing Testing - Queue management
# 8.  Orchestrator Workflow Testing - Dependency graph testing
# 9.  Data Flow Bus Testing - Inter-module communication
# 10. Intelligence Engine Testing - Pattern recognition
# 11. Plugin System Testing - Plugin lifecycle
# 12. Logging System Validation - Log levels and formatting
# 13. Proxy and Network Testing - Network error handling
# 14. Output Format Testing - Report generation
# 15. Security and Permissions - File security testing
# 16. Memory and Resource Usage - Resource monitoring
# 17. Cross-Platform Compatibility - Multi-OS testing
# 18. CLI Interface Testing - Argument parsing
# 19. State Management Testing - Resume functionality
# 20. Wordlist and Pattern Testing - Pattern matching
# 21. Advanced Features Integration - Advanced feature testing
# 22. Documentation Consistency - README validation
# 23. Performance Benchmarking - Execution timing
# 24. Environment Setup Validation - Setup scripts
# 25. Final Summary and Artifact Collection
#
# ARCHITECTURE NOTES:
# - Complex bash logic is in .github/scripts/ for proper error handling
# - Uses `set -euo pipefail` in helper scripts
# - All jobs upload detailed artifacts for analysis
# - Matrix builds for cross-platform testing
################################################################################

name: Neko Comprehensive Testing Suite

on:
  push:
    branches: [ main, master, develop, 'feature/**' ]
  pull_request:
    branches: [ main, master, develop ]
  workflow_dispatch:
    inputs:
      debug_enabled:
        description: 'Enable extra debug logging'
        required: false
        default: 'true'
        type: boolean
      run_performance_tests:
        description: 'Run performance benchmarks (slower)'
        required: false
        default: 'false'
        type: boolean
      run_cross_platform:
        description: 'Run cross-platform tests (matrix builds)'
        required: false
        default: 'true'
        type: boolean
      test_categories:
        description: 'Test categories to run (all, core, integration, advanced)'
        required: false
        default: 'all'
        type: choice
        options:
          - all
          - core
          - integration
          - advanced

env:
  VERBOSE_LOGGING: 'true'
  DEBUG_MODE: 'true'
  LOG_TIMESTAMP_FORMAT: '%Y-%m-%d %H:%M:%S'
  TOOLS_PATH: /home/runner/Tools
  WORDLISTS_PATH: /home/runner/Tools/wordlists
  TEST_DOMAIN: 'test.example.com'
  TEST_MODE: 'true'
  NEKO_TEST_RUN: 'true'
  CI_ENVIRONMENT: 'github-actions'

################################################################################
# JOBS - Organized by Testing Category
################################################################################

jobs:

  ################################################################################
  # SETUP JOB - Initialize environment and generate run metadata
  ################################################################################
  setup:
    name: "0. Setup & Environment Info"
    runs-on: ubuntu-latest
    outputs:
      timestamp: ${{ steps.meta.outputs.timestamp }}
      run_id: ${{ steps.meta.outputs.run_id }}
      artifact_prefix: ${{ steps.meta.outputs.artifact_prefix }}
    steps:
      - name: Generate Metadata
        id: meta
        run: |
          set -euo pipefail
          TIMESTAMP=$(date +"%Y%m%d_%H%M%S")
          RUN_ID="neko_test_${TIMESTAMP}_${{ github.run_number }}"
          ARTIFACT_PREFIX="neko-test-${TIMESTAMP}"

          printf 'timestamp=%s\n' "$TIMESTAMP" >> "$GITHUB_OUTPUT"
          printf 'run_id=%s\n' "$RUN_ID" >> "$GITHUB_OUTPUT"
          printf 'artifact_prefix=%s\n' "$ARTIFACT_PREFIX" >> "$GITHUB_OUTPUT"

          printf '%s\n' "╔══════════════════════════════════════════════════════════════╗"
          printf '%s\n' "║     NEKO COMPREHENSIVE TESTING SUITE                         ║"
          printf '%s\n' "╠══════════════════════════════════════════════════════════════╣"
          printf '%s\n' "║ Run ID: ${RUN_ID}"
          printf '%s\n' "║ Timestamp: ${TIMESTAMP}"
          printf '%s\n' "║ Event: ${{ github.event_name }}"
          printf '%s\n' "║ Ref: ${{ github.ref }}"
          printf '%s\n' "║ Actor: ${{ github.actor }}"
          printf '%s\n' "╚══════════════════════════════════════════════════════════════╝"

      - name: System Information
        run: |
          set -euo pipefail
          printf '%s\n' "=== Operating System ==="
          cat /etc/os-release
          printf '\n%s\n' "=== Kernel ==="
          uname -a
          printf '\n%s\n' "=== CPU ==="
          nproc
          printf '\n%s\n' "=== Memory ==="
          free -h
          printf '\n%s\n' "=== Disk ==="
          df -h /
          printf '\n%s\n' "=== Bash Version ==="
          bash --version | head -1

  ################################################################################
  # 1. INTEGRATION TESTING
  # Test complete scan flows end-to-end without actual targets
  ################################################################################
  integration-testing:
    name: "1. Integration Testing"
    runs-on: ubuntu-latest
    needs: setup
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Create Log Directory
        run: mkdir -p logs/integration

      - name: Setup Test Environment
        run: |
          set -euo pipefail
          chmod +x neko.sh install.sh run_tests.sh 2>/dev/null || true
          chmod +x modules/*.sh lib/*.sh 2>/dev/null || true
          chmod +x .github/scripts/*.sh 2>/dev/null || true

      - name: Test Phase Transitions
        run: |
          set -euo pipefail
          exec > >(tee logs/integration/phase_transitions.log) 2>&1

          printf '%s\n' "=== Testing Phase Transition Logic ==="

          source neko.cfg 2>/dev/null || true
          export SCRIPTPATH="$(pwd)"
          export domain="test.example.com"
          export mode="test"
          export dir="/tmp/neko_test_$$"
          export called_fn_dir="${dir}/.called"
          export LOGFILE="${dir}/test.log"

          mkdir -p "$dir"/{logs,subdomains,dns,hosts,webs,ports,.tmp,.called}
          touch "$LOGFILE"

          for lib in lib/*.sh; do
            source "$lib" 2>/dev/null || printf '[WARN] Failed to load: %s\n' "$lib"
          done

          PHASES=(
            "00_osint:osint_main"
            "01_subdomain:subdomain_main"
            "02_dns:dns_main"
            "03_webprobe:webprobe_main"
            "04_portscan:portscan_main"
            "05_content:content_main"
          )

          for phase_info in "${PHASES[@]}"; do
            module="${phase_info%%:*}"
            main_func="${phase_info##*:}"

            printf '\n--- Testing phase: %s ---\n' "$module"

            if [[ -f "modules/${module}.sh" ]]; then
              if source "modules/${module}.sh" 2>/dev/null; then
                printf '[PASS] Module loaded: %s\n' "$module"

                if type -t "$main_func" &>/dev/null; then
                  printf '[PASS] Main function available: %s\n' "$main_func"
                else
                  printf '[WARN] Main function not found: %s\n' "$main_func"
                fi
              else
                printf '[FAIL] Failed to load module: %s\n' "$module"
              fi
            else
              printf '[SKIP] Module not found: modules/%s.sh\n' "$module"
            fi
          done

          rm -rf "$dir" 2>/dev/null || true
          printf '\n[COMPLETE] Phase transition testing finished\n'

      - name: Test Data Flow Between Modules
        run: |
          set -euo pipefail
          exec > >(tee logs/integration/data_flow.log) 2>&1

          printf '%s\n' "=== Testing Inter-Module Data Flow ==="

          source neko.cfg 2>/dev/null || true
          export SCRIPTPATH="$(pwd)"
          export dir="/tmp/neko_dataflow_$$"

          mkdir -p "$dir"/{subdomains,dns,hosts,webs,ports,urls}

          printf '%s\n' "sub1.example.com" > "$dir/subdomains/subdomains.txt"
          printf '%s\n' "sub2.example.com" >> "$dir/subdomains/subdomains.txt"
          printf '%s\n' "sub3.example.com" >> "$dir/subdomains/subdomains.txt"

          SUBDOMAIN_COUNT=$(wc -l < "$dir/subdomains/subdomains.txt")
          printf '[TEST] Created %d test subdomains\n' "$SUBDOMAIN_COUNT"

          printf '%s\n' "sub1.example.com:192.168.1.1" > "$dir/dns/resolved.txt"
          printf '%s\n' "sub2.example.com:192.168.1.2" >> "$dir/dns/resolved.txt"

          printf '%s\n' "https://sub1.example.com" > "$dir/webs/webs.txt"
          printf '%s\n' "http://sub2.example.com" >> "$dir/webs/webs.txt"

          if [[ -f "$dir/subdomains/subdomains.txt" ]] && [[ -f "$dir/dns/resolved.txt" ]]; then
            printf '[PASS] Data flow from subdomains to DNS working\n'
          else
            printf '[FAIL] Data flow issue detected\n'
          fi

          if [[ -f "$dir/webs/webs.txt" ]]; then
            WEB_COUNT=$(wc -l < "$dir/webs/webs.txt")
            printf '[PASS] Web probing data available: %d hosts\n' "$WEB_COUNT"
          fi

          rm -rf "$dir" 2>/dev/null || true
          printf '\n[COMPLETE] Data flow testing finished\n'

      - name: Test Output File Generation
        run: |
          set -euo pipefail
          exec > >(tee logs/integration/output_files.log) 2>&1

          printf '%s\n' "=== Testing Output File Structure ==="

          export dir="/tmp/neko_output_$$"

          EXPECTED_DIRS=(
            "logs" "osint" "subdomains" "dns" "hosts" "webs" "ports"
            "content" "technologies" "urls" "js" "parameters"
            "vulnerabilities" "xss" "takeover" "cloud" "auth" "api"
            "reports" ".tmp"
          )

          mkdir -p "$dir"
          for subdir in "${EXPECTED_DIRS[@]}"; do
            mkdir -p "$dir/$subdir"
          done

          for subdir in "${EXPECTED_DIRS[@]}"; do
            if [[ -d "$dir/$subdir" ]]; then
              printf '[PASS] Directory created: %s\n' "$subdir"
            else
              printf '[FAIL] Directory missing: %s\n' "$subdir"
            fi
          done

          rm -rf "$dir" 2>/dev/null || true
          printf '\n[COMPLETE] Output file structure testing finished\n'

      - name: Test Cleanup and State Management
        run: |
          set -euo pipefail
          exec > >(tee logs/integration/cleanup_state.log) 2>&1

          printf '%s\n' "=== Testing Cleanup and State Management ==="

          source neko.cfg 2>/dev/null || true
          for lib in lib/*.sh; do
            source "$lib" 2>/dev/null || true
          done

          export dir="/tmp/neko_state_$$"
          export called_fn_dir="${dir}/.called"
          mkdir -p "$called_fn_dir"

          touch "$called_fn_dir/.osint_completed"
          touch "$called_fn_dir/.subdomain_completed"
          touch "$called_fn_dir/.dns_completed"

          for marker in osint subdomain dns; do
            if [[ -f "$called_fn_dir/.${marker}_completed" ]]; then
              printf '[PASS] State marker exists: %s\n' "$marker"
            else
              printf '[FAIL] State marker missing: %s\n' "$marker"
            fi
          done

          rm -rf "$dir" 2>/dev/null || true

          if [[ ! -d "$dir" ]]; then
            printf '[PASS] Cleanup successful\n'
          else
            printf '[FAIL] Cleanup failed\n'
          fi

          printf '\n[COMPLETE] Cleanup and state testing finished\n'

      - name: Upload Integration Test Logs
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: integration-testing-${{ needs.setup.outputs.artifact_prefix }}
          path: logs/integration/
          retention-days: 30

  ################################################################################
  # 2. LIBRARY DEPENDENCY CHAIN TESTING
  # Test library loading order and dependencies
  ################################################################################
  library-dependency-testing:
    name: "2. Library Dependency Chain"
    runs-on: ubuntu-latest
    needs: setup
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Create Log Directory
        run: mkdir -p logs/library-deps

      - name: Test Library Loading Order
        run: |
          set -euo pipefail
          exec > >(tee logs/library-deps/loading_order.log) 2>&1

          printf '%s\n' "=== Testing Library Loading Order ==="

          CORRECT_ORDER=(
            "core.sh"
            "logging.sh"
            "error_handling.sh"
            "error_reporting.sh"
            "parallel.sh"
            "async_pipeline.sh"
            "queue_manager.sh"
            "data_flow_bus.sh"
            "orchestrator.sh"
            "proxy_rotation.sh"
            "intelligence.sh"
            "plugin.sh"
            "discord_notifications.sh"
          )

          source neko.cfg 2>/dev/null || true
          export SCRIPTPATH="$(pwd)"
          export domain="test.example.com"
          export mode="test"
          export dir="/tmp/neko_libtest_$$"
          export called_fn_dir="${dir}/.called"
          export LOGFILE="${dir}/test.log"
          export TOOLS_PATH="${TOOLS_PATH:-/tmp/Tools}"

          mkdir -p "$dir"/{logs,.called,.tmp}
          mkdir -p "$TOOLS_PATH"
          touch "$LOGFILE"

          LOAD_SUCCESS=0
          LOAD_FAIL=0

          for lib in "${CORRECT_ORDER[@]}"; do
            printf '\n--- Loading: %s ---\n' "$lib"

            if [[ -f "lib/$lib" ]]; then
              if source "lib/$lib" 2>&1; then
                printf '[PASS] Loaded: %s\n' "$lib"
                ((LOAD_SUCCESS++)) || true
              else
                printf '[FAIL] Error loading: %s\n' "$lib"
                ((LOAD_FAIL++)) || true
              fi
            else
              printf '[SKIP] Not found: %s\n' "$lib"
            fi
          done

          printf '\n=== Loading Summary ===\n'
          printf 'Successful: %d\n' "$LOAD_SUCCESS"
          printf 'Failed: %d\n' "$LOAD_FAIL"

          rm -rf "$dir" 2>/dev/null || true

      - name: Test Inter-Library Function Calls
        run: |
          set -euo pipefail
          exec > >(tee logs/library-deps/inter_library.log) 2>&1

          printf '%s\n' "=== Testing Inter-Library Function Calls ==="

          source neko.cfg 2>/dev/null || true
          export SCRIPTPATH="$(pwd)"
          export dir="/tmp/neko_interlib_$$"
          export called_fn_dir="${dir}/.called"
          export LOGFILE="${dir}/test.log"
          export TOOLS_PATH="${TOOLS_PATH:-/tmp/Tools}"

          mkdir -p "$dir"/{logs,.called}
          mkdir -p "$TOOLS_PATH"
          touch "$LOGFILE"

          for lib in lib/*.sh; do
            source "$lib" 2>/dev/null || true
          done

          CORE_FUNCS=("command_exists" "ensure_dir" "timestamp" "validate_domain" "is_ip" "count_lines")

          printf '\n--- Core Functions ---\n'
          for func in "${CORE_FUNCS[@]}"; do
            if type -t "$func" &>/dev/null; then
              printf '[AVAILABLE] %s\n' "$func"
            else
              printf '[MISSING] %s\n' "$func"
            fi
          done

          LOGGING_FUNCS=("log_info" "log_error" "log_warning" "log_success" "log_debug")

          printf '\n--- Logging Functions ---\n'
          for func in "${LOGGING_FUNCS[@]}"; do
            if type -t "$func" &>/dev/null; then
              printf '[AVAILABLE] %s\n' "$func"
            else
              printf '[MISSING] %s\n' "$func"
            fi
          done

          rm -rf "$dir" 2>/dev/null || true

      - name: Test Circular Dependency Detection
        run: |
          set -euo pipefail
          exec > >(tee logs/library-deps/circular_deps.log) 2>&1

          printf '%s\n' "=== Checking for Circular Dependencies ==="

          for lib in lib/*.sh; do
            libname=$(basename "$lib")
            printf '\n--- Checking: %s ---\n' "$libname"

            SOURCES=$(grep -E "^\s*(source|\.)\s+" "$lib" 2>/dev/null | grep -v "^#" || true)

            if [[ -n "$SOURCES" ]]; then
              printf 'Source statements found:\n%s\n' "$SOURCES"

              if echo "$SOURCES" | grep -q "$libname"; then
                printf '[WARN] Potential self-reference detected\n'
              else
                printf '[OK] No self-reference\n'
              fi
            else
              printf '[OK] No source statements in this library\n'
            fi
          done

      - name: Test Library Isolation
        run: |
          set -euo pipefail
          exec > >(tee logs/library-deps/isolation.log) 2>&1

          printf '%s\n' "=== Testing Library Isolation ==="

          for lib in lib/*.sh; do
            libname=$(basename "$lib" .sh)
            printf '\n--- Testing isolation: %s ---\n' "$libname"

            GLOBAL_VARS=$(grep -E "^[A-Z_]+=" "$lib" 2>/dev/null | head -10 || true)

            if [[ -n "$GLOBAL_VARS" ]]; then
              printf 'Global variables defined:\n%s\n' "$GLOBAL_VARS"
            else
              printf '[OK] No direct global variable definitions\n'
            fi

            DECLARED_GLOBALS=$(grep -E "^declare\s+-g" "$lib" 2>/dev/null | head -5 || true)
            if [[ -n "$DECLARED_GLOBALS" ]]; then
              printf 'Declared globals:\n%s\n' "$DECLARED_GLOBALS"
            fi
          done

      - name: Upload Library Dependency Logs
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: library-dependency-${{ needs.setup.outputs.artifact_prefix }}
          path: logs/library-deps/
          retention-days: 30

  ################################################################################
  # 3. MODULE FUNCTION COVERAGE
  # Test every function in each module individually
  ################################################################################
  module-function-coverage:
    name: "3. Module Function Coverage"
    runs-on: ubuntu-latest
    needs: setup
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Create Log Directory
        run: mkdir -p logs/module-coverage

      - name: Run Module Function Coverage Tests
        run: |
          set -euo pipefail
          chmod +x .github/scripts/test-module-function-coverage.sh 2>/dev/null || true

          if [[ -f .github/scripts/test-module-function-coverage.sh ]]; then
            ./.github/scripts/test-module-function-coverage.sh
          else
            exec > >(tee logs/module-coverage/function_coverage.log) 2>&1

            printf '%s\n' "=== Module Function Coverage Testing ==="

            source neko.cfg 2>/dev/null || true
            export SCRIPTPATH="$(pwd)"
            export domain="test.example.com"
            export mode="test"
            export dir="/tmp/neko_modtest_$$"
            export called_fn_dir="${dir}/.called"
            export LOGFILE="${dir}/test.log"
            export TOOLS_PATH="${TOOLS_PATH:-/tmp/Tools}"

            mkdir -p "$dir"/{logs,osint,subdomains,dns,hosts,webs,ports,content,technologies,urls,js,parameters,vulnerabilities,xss,takeover,cloud,auth,api,reports,.tmp,.called}
            mkdir -p "$TOOLS_PATH"
            touch "$LOGFILE"

            for lib in lib/*.sh; do
              source "$lib" 2>/dev/null || true
            done

            TOTAL_FUNCS=0
            DEFINED_FUNCS=0

            for module in modules/*.sh; do
              modname=$(basename "$module" .sh)
              printf '\n═══ Module: %s ═══\n' "$modname"

              if source "$module" 2>/dev/null; then
                printf '[LOADED] Module sourced successfully\n'

                FUNCS=$(grep -E "^[a-z_]+\(\)\s*\{" "$module" 2>/dev/null | sed 's/().*//' || true)

                if [[ -n "$FUNCS" ]]; then
                  while IFS= read -r func; do
                    ((TOTAL_FUNCS++)) || true

                    if type -t "$func" &>/dev/null; then
                      printf '  [OK] %s\n' "$func"
                      ((DEFINED_FUNCS++)) || true
                    else
                      printf '  [MISSING] %s\n' "$func"
                    fi
                  done <<< "$FUNCS"
                fi
              else
                printf '[FAIL] Could not load module\n'
              fi
            done

            printf '\n═══ Summary ═══\n'
            printf 'Total functions found: %d\n' "$TOTAL_FUNCS"
            printf 'Functions defined: %d\n' "$DEFINED_FUNCS"

            rm -rf "$dir" 2>/dev/null || true
          fi

      - name: Test Function Parameter Handling
        run: |
          set -euo pipefail
          exec > >(tee logs/module-coverage/parameter_handling.log) 2>&1

          printf '%s\n' "=== Testing Function Parameter Handling ==="

          source neko.cfg 2>/dev/null || true
          export SCRIPTPATH="$(pwd)"
          export dir="/tmp/neko_params_$$"
          export called_fn_dir="${dir}/.called"
          export LOGFILE="${dir}/test.log"

          mkdir -p "$dir"/{logs,.called}
          touch "$LOGFILE"

          for lib in lib/*.sh; do
            source "$lib" 2>/dev/null || true
          done

          printf '\n--- Testing validate_domain ---\n'
          if type -t validate_domain &>/dev/null; then
            DOMAIN_TESTS=(
              "example.com:valid"
              "sub.example.com:valid"
              "192.168.1.1:valid"
              "10.0.0.0/24:valid"
              "invalid domain:invalid"
              ":invalid"
              "..com:invalid"
            )

            for test in "${DOMAIN_TESTS[@]}"; do
              domain_input="${test%%:*}"
              expected="${test##*:}"

              if validate_domain "$domain_input" 2>/dev/null; then
                result="valid"
              else
                result="invalid"
              fi

              if [[ "$result" == "$expected" ]]; then
                printf '[PASS] validate_domain("%s") = %s\n' "$domain_input" "$result"
              else
                printf '[FAIL] validate_domain("%s") = %s (expected: %s)\n' "$domain_input" "$result" "$expected"
              fi
            done
          fi

          printf '\n--- Testing count_lines ---\n'
          if type -t count_lines &>/dev/null; then
            printf 'line1\nline2\nline3\n' > /tmp/test_count_$$
            count=$(count_lines /tmp/test_count_$$)
            rm -f /tmp/test_count_$$

            if [[ "$count" == "3" ]]; then
              printf '[PASS] count_lines returned: %s\n' "$count"
            else
              printf '[FAIL] count_lines returned: %s (expected: 3)\n' "$count"
            fi

            empty_count=$(count_lines /tmp/nonexistent_file_$$ 2>/dev/null || echo "0")
            printf '[INFO] count_lines on nonexistent file: %s\n' "$empty_count"
          fi

          rm -rf "$dir" 2>/dev/null || true

      - name: Test Return Codes and Error Handling
        run: |
          set -euo pipefail
          exec > >(tee logs/module-coverage/return_codes.log) 2>&1

          printf '%s\n' "=== Testing Return Codes and Error Handling ==="

          source neko.cfg 2>/dev/null || true
          for lib in lib/*.sh; do
            source "$lib" 2>/dev/null || true
          done

          printf '\n--- Testing command_exists return codes ---\n'
          if type -t command_exists &>/dev/null; then
            if command_exists bash; then
              printf '[PASS] command_exists bash returns 0\n'
            else
              printf '[FAIL] command_exists bash should return 0\n'
            fi

            if ! command_exists nonexistent_cmd_xyz_123; then
              printf '[PASS] command_exists nonexistent returns non-zero\n'
            else
              printf '[FAIL] command_exists nonexistent should return non-zero\n'
            fi
          fi

          printf '\n--- Testing is_ip return codes ---\n'
          if type -t is_ip &>/dev/null; then
            if is_ip "192.168.1.1"; then
              printf '[PASS] is_ip("192.168.1.1") returns 0\n'
            else
              printf '[FAIL] is_ip("192.168.1.1") should return 0\n'
            fi

            if ! is_ip "example.com"; then
              printf '[PASS] is_ip("example.com") returns non-zero\n'
            else
              printf '[FAIL] is_ip("example.com") should return non-zero\n'
            fi
          fi

      - name: Upload Module Coverage Logs
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: module-coverage-${{ needs.setup.outputs.artifact_prefix }}
          path: logs/module-coverage/
          retention-days: 30

  ################################################################################
  # 4. CONFIGURATION VALIDATION SUITE
  # Test all configuration options and combinations
  ################################################################################
  config-validation-suite:
    name: "4. Configuration Validation"
    runs-on: ubuntu-latest
    needs: setup
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Create Log Directory
        run: mkdir -p logs/config-validation

      - name: Test All Configuration Options
        run: |
          set -euo pipefail
          exec > >(tee logs/config-validation/all_options.log) 2>&1

          printf '%s\n' "=== Testing All Configuration Options ==="

          CONFIG_FILE="neko.cfg"

          if [[ ! -f "$CONFIG_FILE" ]]; then
            printf '[FAIL] Configuration file not found: %s\n' "$CONFIG_FILE"
            exit 1
          fi

          printf '\n--- Configuration File Stats ---\n'
          printf 'File: %s\n' "$CONFIG_FILE"
          printf 'Size: %s bytes\n' "$(wc -c < "$CONFIG_FILE")"
          printf 'Lines: %s\n' "$(wc -l < "$CONFIG_FILE")"

          VAR_COUNT=$(grep -cE '^\s*[A-Z_]+=' "$CONFIG_FILE" 2>/dev/null || echo 0)
          printf 'Variables: %d\n' "$VAR_COUNT"

          source "$CONFIG_FILE"

          printf '\n--- Phase Toggle Variables ---\n'
          PHASE_TOGGLES=(
            "OSINT_ENABLED"
            "SUBDOMAIN_ENABLED"
            "DNS_ENABLED"
            "WEBPROBE_ENABLED"
            "PORTSCAN_ENABLED"
            "CONTENT_ENABLED"
            "FINGERPRINT_ENABLED"
            "URLANALYSIS_ENABLED"
            "PARAM_ENABLED"
            "VULNSCAN_ENABLED"
            "XSS_ENABLED"
            "TAKEOVER_ENABLED"
            "CLOUD_ENABLED"
            "AUTH_ENABLED"
            "API_ENABLED"
            "REPORT_ENABLED"
          )

          for var in "${PHASE_TOGGLES[@]}"; do
            if [[ -n "${!var+x}" ]]; then
              printf '[SET] %s = %s\n' "$var" "${!var}"
            else
              printf '[UNSET] %s\n' "$var"
            fi
          done

          printf '\n--- Threading Variables ---\n'
          THREAD_VARS=(
            "SUBFINDER_THREADS"
            "HTTPX_THREADS"
            "NUCLEI_THREADS"
            "FFUF_THREADS"
            "NMAP_THREADS"
          )

          for var in "${THREAD_VARS[@]}"; do
            if [[ -n "${!var+x}" ]]; then
              printf '[SET] %s = %s\n' "$var" "${!var}"
            else
              printf '[UNSET] %s\n' "$var"
            fi
          done

      - name: Test Environment Variable Handling
        run: |
          set -euo pipefail
          exec > >(tee logs/config-validation/env_handling.log) 2>&1

          printf '%s\n' "=== Testing Environment Variable Handling ==="

          export TEST_OVERRIDE_VAR="test_value_123"

          source neko.cfg

          printf '\n--- Testing variable presence ---\n'
          if [[ -n "${TOOLS_PATH:-}" ]]; then
            printf '[OK] TOOLS_PATH is set: %s\n' "$TOOLS_PATH"
          else
            printf '[WARN] TOOLS_PATH is not set\n'
          fi

          if [[ -n "${USER_AGENT:-}" ]]; then
            printf '[OK] USER_AGENT is set\n'
          else
            printf '[WARN] USER_AGENT is not set\n'
          fi

          printf '\n--- Testing path expansion ---\n'
          if [[ "${TOOLS_PATH:-}" == *"$HOME"* ]] || [[ "${TOOLS_PATH:-}" == *"~"* ]] || [[ "${TOOLS_PATH:-}" == /home/* ]] || [[ "${TOOLS_PATH:-}" == /tmp/* ]]; then
            printf '[OK] TOOLS_PATH contains path reference\n'
          else
            printf '[INFO] TOOLS_PATH value: %s\n' "${TOOLS_PATH:-unset}"
          fi

      - name: Test Config File Parsing Edge Cases
        run: |
          set -euo pipefail
          exec > >(tee logs/config-validation/edge_cases.log) 2>&1

          printf '%s\n' "=== Testing Config Parsing Edge Cases ==="

          printf '\n--- Checking for empty values ---\n'
          EMPTY_VARS=$(grep -E '^\s*[A-Z_]+=""' neko.cfg 2>/dev/null | head -20 || true)
          if [[ -n "$EMPTY_VARS" ]]; then
            printf 'Variables with empty values:\n%s\n' "$EMPTY_VARS"
          else
            printf '[OK] No empty quoted values found\n'
          fi

          printf '\n--- Checking for commented variables ---\n'
          COMMENTED=$(grep -E '^\s*#\s*[A-Z_]+=' neko.cfg 2>/dev/null | head -10 || true)
          if [[ -n "$COMMENTED" ]]; then
            printf 'Commented variables (examples):\n%s\n' "$COMMENTED"
          fi

          printf '\n--- Checking for special characters ---\n'
          SPECIAL_CHARS=$(grep -E '^\s*[A-Z_]+=.*[&|;`$]' neko.cfg 2>/dev/null | grep -v "^\s#" | head -10 || true)
          if [[ -n "$SPECIAL_CHARS" ]]; then
            printf 'Variables with special characters:\n%s\n' "$SPECIAL_CHARS"
          else
            printf '[OK] No potentially dangerous special characters in values\n'
          fi

      - name: Test Default Value Fallbacks
        run: |
          set -euo pipefail
          exec > >(tee logs/config-validation/default_fallbacks.log) 2>&1

          printf '%s\n' "=== Testing Default Value Fallbacks ==="

          printf '\n--- Testing unset variable fallbacks ---\n'

          unset UNDEFINED_VAR 2>/dev/null || true

          RESULT="${UNDEFINED_VAR:-default_value}"
          if [[ "$RESULT" == "default_value" ]]; then
            printf '[PASS] Fallback for unset variable works\n'
          else
            printf '[FAIL] Fallback returned: %s\n' "$RESULT"
          fi

          source neko.cfg

          printf '\n--- Testing config fallbacks ---\n'

          DEBUG_VALUE="${DEBUG:-false}"
          printf 'DEBUG fallback: %s\n' "$DEBUG_VALUE"

          PROXY_VALUE="${PROXY_URL:-none}"
          printf 'PROXY_URL fallback: %s\n' "$PROXY_VALUE"

      - name: Upload Config Validation Logs
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: config-validation-${{ needs.setup.outputs.artifact_prefix }}
          path: logs/config-validation/
          retention-days: 30

  ################################################################################
  # 5. TOOL AVAILABILITY MOCK TESTING
  # Simulate missing tools and test fallback mechanisms
  ################################################################################
  tool-mock-testing:
    name: "5. Tool Mock Testing"
    runs-on: ubuntu-latest
    needs: setup
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Create Log Directory
        run: mkdir -p logs/tool-mock

      - name: Test Missing Tool Fallbacks
        run: |
          set -euo pipefail
          exec > >(tee logs/tool-mock/missing_tools.log) 2>&1

          printf '%s\n' "=== Testing Missing Tool Fallbacks ==="

          source neko.cfg 2>/dev/null || true
          for lib in lib/*.sh; do
            source "$lib" 2>/dev/null || true
          done

          TOOLS_TO_CHECK=(
            "subfinder"
            "amass"
            "httpx"
            "nuclei"
            "ffuf"
            "nmap"
            "masscan"
            "dalfox"
            "katana"
            "gau"
            "waybackurls"
            "dnsx"
            "puredns"
            "sqlmap"
            "gobuster"
          )

          AVAILABLE=0
          MISSING=0

          for tool in "${TOOLS_TO_CHECK[@]}"; do
            if type -t command_exists &>/dev/null; then
              if command_exists "$tool"; then
                printf '[AVAILABLE] %s\n' "$tool"
                ((AVAILABLE++)) || true
              else
                printf '[MISSING] %s\n' "$tool"
                ((MISSING++)) || true
              fi
            else
              if command -v "$tool" &>/dev/null; then
                printf '[AVAILABLE] %s\n' "$tool"
                ((AVAILABLE++)) || true
              else
                printf '[MISSING] %s\n' "$tool"
                ((MISSING++)) || true
              fi
            fi
          done

          printf '\n=== Summary ===\n'
          printf 'Available: %d\n' "$AVAILABLE"
          printf 'Missing: %d\n' "$MISSING"

      - name: Test Graceful Degradation
        run: |
          set -euo pipefail
          exec > >(tee logs/tool-mock/graceful_degradation.log) 2>&1

          printf '%s\n' "=== Testing Graceful Degradation ==="

          source neko.cfg 2>/dev/null || true
          export SCRIPTPATH="$(pwd)"
          export domain="test.example.com"
          export dir="/tmp/neko_degrade_$$"
          export called_fn_dir="${dir}/.called"

          mkdir -p "$dir"/{logs,.called}

          for lib in lib/*.sh; do
            source "$lib" 2>/dev/null || true
          done

          printf '\n--- Testing with_rate_limit fallback ---\n'
          if type -t with_rate_limit &>/dev/null; then
            with_rate_limit echo "test" 2>/dev/null && printf '[PASS] with_rate_limit works\n' || printf '[INFO] with_rate_limit returned non-zero\n'
          else
            printf '[SKIP] with_rate_limit not defined\n'
          fi

          printf '\n--- Testing run_managed fallback ---\n'
          if type -t run_managed &>/dev/null; then
            printf '[AVAILABLE] run_managed function exists\n'
          else
            printf '[SKIP] run_managed not defined\n'
          fi

          rm -rf "$dir" 2>/dev/null || true

      - name: Test Tool Version Compatibility
        run: |
          set -euo pipefail
          exec > >(tee logs/tool-mock/version_compat.log) 2>&1

          printf '%s\n' "=== Testing Tool Version Compatibility ==="

          check_version() {
            local tool="$1"
            local version_cmd="${2:---version}"

            if command -v "$tool" &>/dev/null; then
              local version
              version=$("$tool" $version_cmd 2>/dev/null | head -1 || echo "unknown")
              printf '[OK] %s: %s\n' "$tool" "$version"
            else
              printf '[MISSING] %s\n' "$tool"
            fi
          }

          printf '\n--- System Tools ---\n'
          check_version bash "--version"
          check_version curl "--version"
          check_version wget "--version"
          check_version git "--version"
          check_version jq "--version"
          check_version python3 "--version"
          check_version go "version"

          printf '\n--- Network Tools ---\n'
          check_version nmap "--version"
          check_version nc "-h" 2>/dev/null || check_version nc "--version"
          check_version dig "-v"
          check_version whois "--version"

      - name: Upload Tool Mock Logs
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: tool-mock-${{ needs.setup.outputs.artifact_prefix }}
          path: logs/tool-mock/
          retention-days: 30

  ################################################################################
  # 6. ERROR HANDLING AND RECOVERY
  # Test all error handling paths
  ################################################################################
  error-handling-recovery:
    name: "6. Error Handling & Recovery"
    runs-on: ubuntu-latest
    needs: setup
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Create Log Directory
        run: mkdir -p logs/error-handling

      - name: Test Error Handling Paths
        run: |
          set -euo pipefail
          exec > >(tee logs/error-handling/error_paths.log) 2>&1

          printf '%s\n' "=== Testing Error Handling Paths ==="

          source neko.cfg 2>/dev/null || true
          export SCRIPTPATH="$(pwd)"
          export dir="/tmp/neko_error_$$"
          export called_fn_dir="${dir}/.called"
          export LOGFILE="${dir}/test.log"

          mkdir -p "$dir"/{logs,.called}
          touch "$LOGFILE"

          for lib in lib/*.sh; do
            source "$lib" 2>/dev/null || true
          done

          printf '\n--- Testing log_error function ---\n'
          if type -t log_error &>/dev/null; then
            log_error "Test error message" 2>/dev/null
            printf '[PASS] log_error executed without crash\n'
          else
            printf '[SKIP] log_error not defined\n'
          fi

          printf '\n--- Testing mark_module_failed ---\n'
          if type -t mark_module_failed &>/dev/null; then
            mark_module_failed "test_module" "Test failure reason" 2>/dev/null
            printf '[PASS] mark_module_failed executed\n'
          else
            printf '[SKIP] mark_module_failed not defined\n'
          fi

          rm -rf "$dir" 2>/dev/null || true

      - name: Test Error Logging Mechanisms
        run: |
          set -euo pipefail
          exec > >(tee logs/error-handling/logging_mechanisms.log) 2>&1

          printf '%s\n' "=== Testing Error Logging Mechanisms ==="

          source neko.cfg 2>/dev/null || true
          for lib in lib/*.sh; do
            source "$lib" 2>/dev/null || true
          done

          printf '\n--- Testing all log levels ---\n'

          LOG_FUNCS=("log_info" "log_success" "log_warning" "log_error" "log_debug")

          for func in "${LOG_FUNCS[@]}"; do
            if type -t "$func" &>/dev/null; then
              $func "Test message from $func" 2>/dev/null || true
              printf '[EXECUTED] %s\n' "$func"
            else
              printf '[MISSING] %s\n' "$func"
            fi
          done

      - name: Test Cleanup After Errors
        run: |
          set -euo pipefail
          exec > >(tee logs/error-handling/cleanup_after_error.log) 2>&1

          printf '%s\n' "=== Testing Cleanup After Errors ==="

          TEST_DIR="/tmp/neko_cleanup_test_$$"
          mkdir -p "$TEST_DIR"
          touch "$TEST_DIR/test_file.txt"

          printf 'Created test directory: %s\n' "$TEST_DIR"

          cleanup_test() {
            rm -rf "$TEST_DIR" 2>/dev/null || true
          }

          trap cleanup_test EXIT

          (
            exit 1
          ) || true

          if [[ ! -d "$TEST_DIR" ]] || cleanup_test; then
            printf '[PASS] Cleanup mechanism works\n'
          fi

      - name: Test Signal Handling
        run: |
          set -euo pipefail
          exec > >(tee logs/error-handling/signal_handling.log) 2>&1

          printf '%s\n' "=== Testing Signal Handling ==="

          printf '\n--- Checking trap definitions in neko.sh ---\n'
          TRAPS=$(grep -E "^\s*trap\s+" neko.sh 2>/dev/null | head -10 || true)
          if [[ -n "$TRAPS" ]]; then
            printf 'Trap definitions found:\n%s\n' "$TRAPS"
          else
            printf '[INFO] No explicit trap definitions in main script\n'
          fi

          printf '\n--- Checking cleanup function ---\n'
          if grep -q "cleanup()" neko.sh 2>/dev/null; then
            printf '[OK] cleanup() function defined in neko.sh\n'
          else
            printf '[INFO] No cleanup() function in neko.sh\n'
          fi

          printf '\n--- Testing trap behavior ---\n'
          (
            trap 'printf "[TRAP] Caught signal\n"' INT TERM
            printf '[OK] Trap set successfully\n'
          )

      - name: Upload Error Handling Logs
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: error-handling-${{ needs.setup.outputs.artifact_prefix }}
          path: logs/error-handling/
          retention-days: 30

  ################################################################################
  # 7. PARALLEL PROCESSING TESTING
  # Test queue management system
  ################################################################################
  parallel-processing-test:
    name: "7. Parallel Processing"
    runs-on: ubuntu-latest
    needs: setup
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Create Log Directory
        run: mkdir -p logs/parallel

      - name: Test Queue Management System
        run: |
          set -euo pipefail
          exec > >(tee logs/parallel/queue_management.log) 2>&1

          printf '%s\n' "=== Testing Queue Management System ==="

          source neko.cfg 2>/dev/null || true
          export SCRIPTPATH="$(pwd)"

          for lib in lib/*.sh; do
            source "$lib" 2>/dev/null || true
          done

          printf '\n--- Queue Functions ---\n'
          QUEUE_FUNCS=(
            "queue_init"
            "queue_add"
            "queue_run"
            "queue_stats"
            "wait_for_slot"
            "release_slot"
          )

          for func in "${QUEUE_FUNCS[@]}"; do
            if type -t "$func" &>/dev/null; then
              printf '[AVAILABLE] %s\n' "$func"
            else
              printf '[MISSING] %s\n' "$func"
            fi
          done

      - name: Test Rate Limiting
        run: |
          set -euo pipefail
          exec > >(tee logs/parallel/rate_limiting.log) 2>&1

          printf '%s\n' "=== Testing Rate Limiting ==="

          source neko.cfg 2>/dev/null || true

          printf '\n--- Rate Limit Variables ---\n'
          RATE_VARS=(
            "HTTPX_RATELIMIT"
            "NUCLEI_RATELIMIT"
            "FFUF_RATELIMIT"
            "MASSCAN_RATE"
            "NMAP_RATE"
          )

          for var in "${RATE_VARS[@]}"; do
            if [[ -n "${!var:-}" ]]; then
              printf '[SET] %s = %s\n' "$var" "${!var}"
            else
              printf '[UNSET] %s\n' "$var"
            fi
          done

          for lib in lib/*.sh; do
            source "$lib" 2>/dev/null || true
          done

          printf '\n--- Rate Limit Functions ---\n'
          if type -t get_rate_limit &>/dev/null; then
            printf '[AVAILABLE] get_rate_limit\n'
          else
            printf '[MISSING] get_rate_limit\n'
          fi

          if type -t with_rate_limit &>/dev/null; then
            printf '[AVAILABLE] with_rate_limit\n'
          else
            printf '[MISSING] with_rate_limit\n'
          fi

      - name: Test Process Slot Management
        run: |
          set -euo pipefail
          exec > >(tee logs/parallel/process_slots.log) 2>&1

          printf '%s\n' "=== Testing Process Slot Management ==="

          source neko.cfg 2>/dev/null || true
          for lib in lib/*.sh; do
            source "$lib" 2>/dev/null || true
          done

          printf '\n--- MAX_PROCS Variables ---\n'
          if declare -p MAX_PROCS &>/dev/null 2>&1; then
            printf '[DEFINED] MAX_PROCS array exists\n'
            for key in "${!MAX_PROCS[@]}"; do
              printf '  %s = %s\n' "$key" "${MAX_PROCS[$key]}"
            done
          else
            printf '[UNDEFINED] MAX_PROCS array\n'
          fi

          printf '\n--- CURRENT_PROCS Variables ---\n'
          if declare -p CURRENT_PROCS &>/dev/null 2>&1; then
            printf '[DEFINED] CURRENT_PROCS array exists\n'
          else
            printf '[UNDEFINED] CURRENT_PROCS array\n'
          fi

      - name: Upload Parallel Processing Logs
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: parallel-processing-${{ needs.setup.outputs.artifact_prefix }}
          path: logs/parallel/
          retention-days: 30

  ################################################################################
  # 8. ORCHESTRATOR WORKFLOW TESTING
  # Test dependency graph building
  ################################################################################
  orchestrator-workflow-test:
    name: "8. Orchestrator Testing"
    runs-on: ubuntu-latest
    needs: setup
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Create Log Directory
        run: mkdir -p logs/orchestrator

      - name: Test Dependency Graph
        run: |
          set -euo pipefail
          exec > >(tee logs/orchestrator/dependency_graph.log) 2>&1

          printf '%s\n' "=== Testing Dependency Graph ==="

          source neko.cfg 2>/dev/null || true
          export SCRIPTPATH="$(pwd)"

          for lib in lib/*.sh; do
            source "$lib" 2>/dev/null || true
          done

          printf '\n--- Orchestrator Functions ---\n'
          ORCH_FUNCS=(
            "orchestrator_init"
            "orchestrator_add_phase"
            "orchestrator_set_dependency"
            "orchestrator_run"
            "orchestrator_get_order"
          )

          for func in "${ORCH_FUNCS[@]}"; do
            if type -t "$func" &>/dev/null; then
              printf '[AVAILABLE] %s\n' "$func"
            else
              printf '[MISSING] %s\n' "$func"
            fi
          done

          printf '\n--- Phase Order Analysis ---\n'
          PHASES=(
            "00_osint"
            "01_subdomain"
            "02_dns"
            "03_webprobe"
            "04_portscan"
            "05_content"
            "06_fingerprint"
            "07_urlanalysis"
            "08_params"
            "09_vulnscan"
          )

          for i in "${!PHASES[@]}"; do
            printf 'Phase %d: %s\n' "$i" "${PHASES[$i]}"
          done

      - name: Test Phase Status Tracking
        run: |
          set -euo pipefail
          exec > >(tee logs/orchestrator/phase_status.log) 2>&1

          printf '%s\n' "=== Testing Phase Status Tracking ==="

          source neko.cfg 2>/dev/null || true
          export dir="/tmp/neko_orch_$$"
          export called_fn_dir="${dir}/.called"

          mkdir -p "$called_fn_dir"

          for lib in lib/*.sh; do
            source "$lib" 2>/dev/null || true
          done

          printf '\n--- Testing status markers ---\n'

          touch "$called_fn_dir/.osint_started"
          if [[ -f "$called_fn_dir/.osint_started" ]]; then
            printf '[OK] Started marker created\n'
          fi

          touch "$called_fn_dir/.osint"
          rm -f "$called_fn_dir/.osint_started"
          if [[ -f "$called_fn_dir/.osint" ]] && [[ ! -f "$called_fn_dir/.osint_started" ]]; then
            printf '[OK] Completed marker created, started marker removed\n'
          fi

          rm -rf "$dir" 2>/dev/null || true

      - name: Upload Orchestrator Logs
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: orchestrator-${{ needs.setup.outputs.artifact_prefix }}
          path: logs/orchestrator/
          retention-days: 30

  ################################################################################
  # 9. DATA FLOW BUS TESTING
  # Test data publishing and subscription
  ################################################################################
  data-flow-bus-test:
    name: "9. Data Flow Bus"
    runs-on: ubuntu-latest
    needs: setup
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Create Log Directory
        run: mkdir -p logs/data-flow

      - name: Test Data Publishing
        run: |
          set -euo pipefail
          exec > >(tee logs/data-flow/publishing.log) 2>&1

          printf '%s\n' "=== Testing Data Publishing ==="

          source neko.cfg 2>/dev/null || true
          export SCRIPTPATH="$(pwd)"

          for lib in lib/*.sh; do
            source "$lib" 2>/dev/null || true
          done

          printf '\n--- Data Bus Functions ---\n'
          BUS_FUNCS=(
            "bus_init"
            "bus_publish"
            "bus_subscribe"
            "bus_get_data"
            "bus_clear"
          )

          for func in "${BUS_FUNCS[@]}"; do
            if type -t "$func" &>/dev/null; then
              printf '[AVAILABLE] %s\n' "$func"
            else
              printf '[MISSING] %s\n' "$func"
            fi
          done

      - name: Test Data Channels
        run: |
          set -euo pipefail
          exec > >(tee logs/data-flow/channels.log) 2>&1

          printf '%s\n' "=== Testing Data Channels ==="

          EXPECTED_CHANNELS=(
            "subdomain_discovery"
            "resolved_hosts"
            "live_hosts"
            "target_ips"
            "web_urls"
            "param_urls"
            "vulnerabilities"
          )

          printf '\n--- Expected Data Channels ---\n'
          for channel in "${EXPECTED_CHANNELS[@]}"; do
            printf 'Channel: %s\n' "$channel"
          done

          if [[ -f "lib/data_flow_bus.sh" ]]; then
            printf '\n--- Channels defined in data_flow_bus.sh ---\n'
            grep -E "channel|CHANNEL" lib/data_flow_bus.sh 2>/dev/null | head -20 || printf '[INFO] No channel definitions found\n'
          fi

      - name: Upload Data Flow Logs
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: data-flow-${{ needs.setup.outputs.artifact_prefix }}
          path: logs/data-flow/
          retention-days: 30

  ################################################################################
  # 10. INTELLIGENCE ENGINE TESTING
  # Test pattern recognition
  ################################################################################
  intelligence-engine-test:
    name: "10. Intelligence Engine"
    runs-on: ubuntu-latest
    needs: setup
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Create Log Directory
        run: mkdir -p logs/intelligence

      - name: Test Intelligence Functions
        run: |
          set -euo pipefail
          exec > >(tee logs/intelligence/functions.log) 2>&1

          printf '%s\n' "=== Testing Intelligence Engine ==="

          source neko.cfg 2>/dev/null || true
          for lib in lib/*.sh; do
            source "$lib" 2>/dev/null || true
          done

          printf '\n--- Intelligence Functions ---\n'
          INTEL_FUNCS=(
            "intel_init"
            "intel_correlate"
            "intel_add_finding"
            "intel_get_severity"
            "intel_deduplicate"
            "intel_generate_report"
          )

          for func in "${INTEL_FUNCS[@]}"; do
            if type -t "$func" &>/dev/null; then
              printf '[AVAILABLE] %s\n' "$func"
            else
              printf '[MISSING] %s\n' "$func"
            fi
          done

          printf '\n--- Intelligence Configuration ---\n'
          INTEL_VARS=(
            "INTELLIGENCE_ENABLED"
            "INTEL_AUTO_CORRELATE"
            "INTEL_ATTACK_CHAINS"
          )

          for var in "${INTEL_VARS[@]}"; do
            if [[ -n "${!var:-}" ]]; then
              printf '[SET] %s = %s\n' "$var" "${!var}"
            else
              printf '[UNSET] %s\n' "$var"
            fi
          done

      - name: Upload Intelligence Logs
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: intelligence-${{ needs.setup.outputs.artifact_prefix }}
          path: logs/intelligence/
          retention-days: 30

  ################################################################################
  # 11. PLUGIN SYSTEM TESTING
  # Test plugin loading and unloading
  ################################################################################
  plugin-system-test:
    name: "11. Plugin System"
    runs-on: ubuntu-latest
    needs: setup
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Create Log Directory
        run: mkdir -p logs/plugins

      - name: Test Plugin Loading
        run: |
          set -euo pipefail
          exec > >(tee logs/plugins/loading.log) 2>&1

          printf '%s\n' "=== Testing Plugin System ==="

          source neko.cfg 2>/dev/null || true
          for lib in lib/*.sh; do
            source "$lib" 2>/dev/null || true
          done

          printf '\n--- Plugin Functions ---\n'
          PLUGIN_FUNCS=(
            "plugin_init"
            "plugin_load"
            "plugin_unload"
            "plugin_list"
            "plugin_register_hook"
            "plugin_run_hooks"
          )

          for func in "${PLUGIN_FUNCS[@]}"; do
            if type -t "$func" &>/dev/null; then
              printf '[AVAILABLE] %s\n' "$func"
            else
              printf '[MISSING] %s\n' "$func"
            fi
          done

          printf '\n--- Plugin Directory ---\n'
          if [[ -d "plugins" ]]; then
            printf '[OK] plugins/ directory exists\n'
            ls -la plugins/ 2>/dev/null || true
          else
            printf '[MISSING] plugins/ directory\n'
          fi

          printf '\n--- Plugin Configuration ---\n'
          if [[ -f "config/plugins.json" ]]; then
            printf '[OK] plugins.json exists\n'
            cat config/plugins.json 2>/dev/null || true
          else
            printf '[MISSING] plugins.json\n'
          fi

      - name: Upload Plugin Logs
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: plugins-${{ needs.setup.outputs.artifact_prefix }}
          path: logs/plugins/
          retention-days: 30

  ################################################################################
  # 12. LOGGING SYSTEM VALIDATION
  # Test all log levels and formatting
  ################################################################################
  logging-system-validation:
    name: "12. Logging System"
    runs-on: ubuntu-latest
    needs: setup
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Create Log Directory
        run: mkdir -p logs/logging-system

      - name: Test Log Levels
        run: |
          set -euo pipefail
          exec > >(tee logs/logging-system/log_levels.log) 2>&1

          printf '%s\n' "=== Testing Log Levels ==="

          source neko.cfg 2>/dev/null || true
          export SCRIPTPATH="$(pwd)"
          export dir="/tmp/neko_log_$$"
          export LOGFILE="${dir}/test.log"

          mkdir -p "$dir"
          touch "$LOGFILE"

          for lib in lib/*.sh; do
            source "$lib" 2>/dev/null || true
          done

          printf '\n--- Log Level Functions ---\n'
          LOG_LEVELS=(
            "log_info:INFO"
            "log_success:SUCCESS"
            "log_warning:WARNING"
            "log_error:ERROR"
            "log_debug:DEBUG"
            "log_phase:PHASE"
            "log_module:MODULE"
          )

          for level_info in "${LOG_LEVELS[@]}"; do
            func="${level_info%%:*}"
            level="${level_info##*:}"

            if type -t "$func" &>/dev/null; then
              $func "Test message for $level" 2>/dev/null || true
              printf '[OK] %s executed\n' "$func"
            else
              printf '[MISSING] %s\n' "$func"
            fi
          done

          rm -rf "$dir" 2>/dev/null || true

      - name: Test Log Formatting
        run: |
          set -euo pipefail
          exec > >(tee logs/logging-system/formatting.log) 2>&1

          printf '%s\n' "=== Testing Log Formatting ==="

          source neko.cfg 2>/dev/null || true

          printf '\n--- Logging Configuration ---\n'
          LOG_VARS=(
            "LOGGING_ENABLED"
            "NEKO_LOG_LEVEL"
            "NEKO_LOG_FORMAT"
            "NEKO_LOG_ROTATE"
          )

          for var in "${LOG_VARS[@]}"; do
            if [[ -n "${!var:-}" ]]; then
              printf '[SET] %s = %s\n' "$var" "${!var}"
            else
              printf '[UNSET] %s\n' "$var"
            fi
          done

      - name: Upload Logging System Logs
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: logging-system-${{ needs.setup.outputs.artifact_prefix }}
          path: logs/logging-system/
          retention-days: 30

  ################################################################################
  # 13. PROXY AND NETWORK TESTING
  # Test proxy rotation logic
  ################################################################################
  proxy-network-test:
    name: "13. Proxy & Network"
    runs-on: ubuntu-latest
    needs: setup
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Create Log Directory
        run: mkdir -p logs/proxy-network

      - name: Test Proxy Configuration
        run: |
          set -euo pipefail
          exec > >(tee logs/proxy-network/proxy_config.log) 2>&1

          printf '%s\n' "=== Testing Proxy Configuration ==="

          source neko.cfg 2>/dev/null || true
          for lib in lib/*.sh; do
            source "$lib" 2>/dev/null || true
          done

          printf '\n--- Proxy Variables ---\n'
          PROXY_VARS=(
            "PROXY_URL"
            "PROXY_ROTATE"
            "TOR_ENABLED"
            "PROXY_LIST"
          )

          for var in "${PROXY_VARS[@]}"; do
            if [[ -n "${!var:-}" ]]; then
              printf '[SET] %s = %s\n' "$var" "${!var}"
            else
              printf '[UNSET] %s\n' "$var"
            fi
          done

          printf '\n--- Proxy Functions ---\n'
          PROXY_FUNCS=(
            "proxy_init"
            "proxy_rotate"
            "proxy_get_current"
            "proxy_test"
            "proxy_cleanup"
          )

          for func in "${PROXY_FUNCS[@]}"; do
            if type -t "$func" &>/dev/null; then
              printf '[AVAILABLE] %s\n' "$func"
            else
              printf '[MISSING] %s\n' "$func"
            fi
          done

      - name: Test Network Error Handling
        run: |
          set -euo pipefail
          exec > >(tee logs/proxy-network/network_errors.log) 2>&1

          printf '%s\n' "=== Testing Network Error Handling ==="

          source neko.cfg 2>/dev/null || true

          printf '\n--- Timeout Variables ---\n'
          TIMEOUT_VARS=(
            "HTTPX_TIMEOUT"
            "CURL_TIMEOUT"
            "WGET_TIMEOUT"
            "NUCLEI_TIMEOUT"
          )

          for var in "${TIMEOUT_VARS[@]}"; do
            if [[ -n "${!var:-}" ]]; then
              printf '[SET] %s = %s\n' "$var" "${!var}"
            else
              printf '[UNSET] %s\n' "$var"
            fi
          done

      - name: Upload Proxy Network Logs
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: proxy-network-${{ needs.setup.outputs.artifact_prefix }}
          path: logs/proxy-network/
          retention-days: 30

  ################################################################################
  # 14. OUTPUT FORMAT TESTING
  # Test report generation
  ################################################################################
  output-format-test:
    name: "14. Output Formats"
    runs-on: ubuntu-latest
    needs: setup
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Create Log Directory
        run: mkdir -p logs/output-format

      - name: Test Report Generation
        run: |
          set -euo pipefail
          exec > >(tee logs/output-format/report_gen.log) 2>&1

          printf '%s\n' "=== Testing Report Generation ==="

          source neko.cfg 2>/dev/null || true

          printf '\n--- Report Configuration ---\n'
          REPORT_VARS=(
            "REPORT_ENABLED"
            "REPORT_HTML"
            "REPORT_MARKDOWN"
            "REPORT_JSON"
            "REPORT_SUMMARY"
          )

          for var in "${REPORT_VARS[@]}"; do
            if [[ -n "${!var:-}" ]]; then
              printf '[SET] %s = %s\n' "$var" "${!var}"
            else
              printf '[UNSET] %s\n' "$var"
            fi
          done

          for lib in lib/*.sh; do
            source "$lib" 2>/dev/null || true
          done

          if [[ -f "modules/15_report.sh" ]]; then
            source "modules/15_report.sh" 2>/dev/null || true
            printf '\n--- Report Functions ---\n'

            REPORT_FUNCS=$(grep -E "^[a-z_]+\(\)" modules/15_report.sh 2>/dev/null | sed 's/().*//' | head -20 || true)
            for func in $REPORT_FUNCS; do
              if type -t "$func" &>/dev/null; then
                printf '[AVAILABLE] %s\n' "$func"
              else
                printf '[MISSING] %s\n' "$func"
              fi
            done
          fi

      - name: Upload Output Format Logs
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: output-format-${{ needs.setup.outputs.artifact_prefix }}
          path: logs/output-format/
          retention-days: 30

  ################################################################################
  # 15. SECURITY AND PERMISSIONS
  # Test file permission handling
  ################################################################################
  security-permissions-test:
    name: "15. Security & Permissions"
    runs-on: ubuntu-latest
    needs: setup
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Create Log Directory
        run: mkdir -p logs/security

      - name: Test File Permissions
        run: |
          set -euo pipefail
          exec > >(tee logs/security/file_permissions.log) 2>&1

          printf '%s\n' "=== Testing File Permissions ==="

          printf '\n--- Script Permissions ---\n'
          for script in neko.sh install.sh run_tests.sh; do
            if [[ -f "$script" ]]; then
              PERMS=$(stat -c "%a" "$script" 2>/dev/null || stat -f "%OLp" "$script" 2>/dev/null || echo "unknown")
              printf '%s: %s\n' "$script" "$PERMS"
            fi
          done

          printf '\n--- Module Permissions ---\n'
          for script in modules/*.sh; do
            PERMS=$(stat -c "%a" "$script" 2>/dev/null || stat -f "%OLp" "$script" 2>/dev/null || echo "unknown")
            printf '%s: %s\n' "$(basename "$script")" "$PERMS"
          done

      - name: Test API Key Masking
        run: |
          set -euo pipefail
          exec > >(tee logs/security/api_key_masking.log) 2>&1

          printf '%s\n' "=== Testing API Key Masking ==="

          printf '\n--- Checking for exposed keys in config ---\n'
          EXPOSED_KEYS=$(grep -E "^\s*[A-Z_]*(KEY|TOKEN|SECRET|PASSWORD)=.+" neko.cfg 2>/dev/null | grep -v '=""' | grep -v "^#" || true)

          if [[ -n "$EXPOSED_KEYS" ]]; then
            printf '[WARN] Potentially exposed secrets (redacted):\n'
            echo "$EXPOSED_KEYS" | sed 's/=.*/=***REDACTED***/'
          else
            printf '[OK] No exposed secrets in config\n'
          fi

          printf '\n--- Checking log masking in code ---\n'
          MASK_PATTERNS=$(grep -r "KEY\|TOKEN\|SECRET" lib/*.sh 2>/dev/null | grep -i "mask\|redact\|hide" | head -5 || true)
          if [[ -n "$MASK_PATTERNS" ]]; then
            printf 'Masking patterns found:\n%s\n' "$MASK_PATTERNS"
          else
            printf '[INFO] No explicit masking patterns found\n'
          fi

      - name: Upload Security Logs
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: security-${{ needs.setup.outputs.artifact_prefix }}
          path: logs/security/
          retention-days: 30

  ################################################################################
  # 16. MEMORY AND RESOURCE USAGE
  # Monitor resource consumption
  ################################################################################
  resource-usage-test:
    name: "16. Resource Usage"
    runs-on: ubuntu-latest
    needs: setup
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Create Log Directory
        run: mkdir -p logs/resource

      - name: Test Resource Limits
        run: |
          set -euo pipefail
          exec > >(tee logs/resource/limits.log) 2>&1

          printf '%s\n' "=== Testing Resource Limits ==="

          source neko.cfg 2>/dev/null || true

          printf '\n--- Resource Limit Variables ---\n'
          RESOURCE_VARS=(
            "MAX_NETWORK_PROCS"
            "MAX_CPU_PROCS"
            "MAX_IO_PROCS"
            "MEMORY_LIMIT"
          )

          for var in "${RESOURCE_VARS[@]}"; do
            if [[ -n "${!var:-}" ]]; then
              printf '[SET] %s = %s\n' "$var" "${!var}"
            else
              printf '[UNSET] %s\n' "$var"
            fi
          done

          printf '\n--- System Resources ---\n'
          printf 'CPU cores: %s\n' "$(nproc)"
          free -h | head -2
          df -h / | tail -1

      - name: Test Process Cleanup
        run: |
          set -euo pipefail
          exec > >(tee logs/resource/cleanup.log) 2>&1

          printf '%s\n' "=== Testing Process Cleanup ==="

          source neko.cfg 2>/dev/null || true
          for lib in lib/*.sh; do
            source "$lib" 2>/dev/null || true
          done

          printf '\n--- Cleanup Functions ---\n'
          CLEANUP_FUNCS=(
            "cleanup"
            "cleanup_all_procs"
            "parallel_cleanup"
            "pipeline_cleanup"
            "proxy_cleanup"
          )

          for func in "${CLEANUP_FUNCS[@]}"; do
            if type -t "$func" &>/dev/null; then
              printf '[AVAILABLE] %s\n' "$func"
            else
              printf '[MISSING] %s\n' "$func"
            fi
          done

      - name: Upload Resource Logs
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: resource-usage-${{ needs.setup.outputs.artifact_prefix }}
          path: logs/resource/
          retention-days: 30

  ################################################################################
  # 17. CROSS-PLATFORM COMPATIBILITY (Matrix Build)
  ################################################################################
  cross-platform-test:
    name: "17. Cross-Platform (${{ matrix.os }})"
    runs-on: ${{ matrix.os }}
    needs: setup
    if: ${{ github.event.inputs.run_cross_platform != 'false' }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, ubuntu-22.04, macos-latest]
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Create Log Directory
        run: mkdir -p logs/cross-platform

      - name: Test Platform Compatibility
        run: |
          set -euo pipefail
          exec > >(tee logs/cross-platform/platform_${{ matrix.os }}.log) 2>&1

          printf '%s\n' "=== Cross-Platform Testing: ${{ matrix.os }} ==="

          printf '\n--- System Info ---\n'
          uname -a

          printf '\n--- Bash Version ---\n'
          bash --version | head -1

          printf '\n--- Syntax Validation ---\n'
          for script in neko.sh install.sh; do
            if bash -n "$script" 2>&1; then
              printf '[PASS] %s\n' "$script"
            else
              printf '[FAIL] %s\n' "$script"
            fi
          done

          printf '\n--- Library Syntax ---\n'
          for lib in lib/*.sh; do
            if bash -n "$lib" 2>&1; then
              printf '[PASS] %s\n' "$(basename "$lib")"
            else
              printf '[FAIL] %s\n' "$(basename "$lib")"
            fi
          done

          printf '\n--- Tool Availability ---\n'
          for tool in bash curl wget git jq; do
            if command -v "$tool" &>/dev/null; then
              printf '[OK] %s\n' "$tool"
            else
              printf '[MISSING] %s\n' "$tool"
            fi
          done

      - name: Upload Cross-Platform Logs
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: cross-platform-${{ matrix.os }}-${{ needs.setup.outputs.artifact_prefix }}
          path: logs/cross-platform/
          retention-days: 30

  ################################################################################
  # 18. CLI INTERFACE TESTING
  # Test all CLI flags and options
  ################################################################################
  cli-interface-test:
    name: "18. CLI Interface"
    runs-on: ubuntu-latest
    needs: setup
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Create Log Directory
        run: mkdir -p logs/cli

      - name: Setup Scripts
        run: |
          chmod +x neko.sh install.sh 2>/dev/null || true
          chmod +x modules/*.sh lib/*.sh 2>/dev/null || true

      - name: Test CLI Flags
        run: |
          set -euo pipefail
          exec > >(tee logs/cli/flags.log) 2>&1

          printf '%s\n' "=== Testing CLI Flags ==="

          printf '\n--- Testing --help ---\n'
          ./neko.sh --help 2>&1 | head -50 || printf '[INFO] Help returned non-zero\n'

          printf '\n--- Testing --version ---\n'
          ./neko.sh --version 2>&1 || printf '[INFO] Version returned non-zero\n'

          printf '\n--- Testing --check-tools ---\n'
          ./neko.sh --check-tools 2>&1 | head -30 || printf '[INFO] Check-tools returned non-zero (expected)\n'

          printf '\n--- Testing -h ---\n'
          ./neko.sh -h 2>&1 | head -20 || printf '[INFO] -h returned non-zero\n'

      - name: Test Invalid Input Handling
        run: |
          set -uo pipefail
          exec > >(tee logs/cli/invalid_input.log) 2>&1

          printf '%s\n' "=== Testing Invalid Input Handling ==="

          printf '\n--- No arguments ---\n'
          ./neko.sh 2>&1 | head -10 || printf '[OK] Correctly fails without arguments\n'

          printf '\n--- Invalid flag ---\n'
          ./neko.sh --invalid-xyz 2>&1 | head -10 || printf '[OK] Correctly rejects invalid flag\n'

          printf '\n--- Empty domain ---\n'
          ./neko.sh -d "" 2>&1 | head -10 || printf '[OK] Correctly rejects empty domain\n'

      - name: Test Help Text Generation
        run: |
          set -euo pipefail
          exec > >(tee logs/cli/help_text.log) 2>&1

          printf '%s\n' "=== Testing Help Text Generation ==="

          HELP_OUTPUT=$(./neko.sh --help 2>&1 || true)

          printf '\n--- Checking for required sections ---\n'

          REQUIRED_SECTIONS=("Usage" "Options" "Examples" "domain")

          for section in "${REQUIRED_SECTIONS[@]}"; do
            if echo "$HELP_OUTPUT" | grep -qi "$section"; then
              printf '[OK] Help contains: %s\n' "$section"
            else
              printf '[MISSING] Help missing: %s\n' "$section"
            fi
          done

      - name: Upload CLI Logs
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: cli-interface-${{ needs.setup.outputs.artifact_prefix }}
          path: logs/cli/
          retention-days: 30

  ################################################################################
  # 19. STATE MANAGEMENT TESTING
  # Test resume functionality
  ################################################################################
  state-management-test:
    name: "19. State Management"
    runs-on: ubuntu-latest
    needs: setup
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Create Log Directory
        run: mkdir -p logs/state

      - name: Test Resume Functionality
        run: |
          set -euo pipefail
          exec > >(tee logs/state/resume.log) 2>&1

          printf '%s\n' "=== Testing Resume Functionality ==="

          source neko.cfg 2>/dev/null || true
          export dir="/tmp/neko_state_$$"
          export called_fn_dir="${dir}/.called"

          mkdir -p "$called_fn_dir"

          for lib in lib/*.sh; do
            source "$lib" 2>/dev/null || true
          done

          printf '\n--- Testing module completion markers ---\n'

          if type -t mark_module_completed &>/dev/null; then
            mark_module_completed "test_module"
            if [[ -f "$called_fn_dir/.test_module" ]]; then
              printf '[PASS] mark_module_completed creates marker\n'
            else
              printf '[FAIL] Marker not created\n'
            fi
          else
            touch "$called_fn_dir/.test_module"
            printf '[INFO] Using manual marker creation\n'
          fi

          if type -t is_module_completed &>/dev/null; then
            if is_module_completed "test_module"; then
              printf '[PASS] is_module_completed detects marker\n'
            else
              printf '[FAIL] Marker not detected\n'
            fi
          else
            if [[ -f "$called_fn_dir/.test_module" ]]; then
              printf '[PASS] Manual marker check works\n'
            fi
          fi

          rm -rf "$dir" 2>/dev/null || true

      - name: Test Checkpoint Creation
        run: |
          set -euo pipefail
          exec > >(tee logs/state/checkpoints.log) 2>&1

          printf '%s\n' "=== Testing Checkpoint Creation ==="

          source neko.cfg 2>/dev/null || true
          for lib in lib/*.sh; do
            source "$lib" 2>/dev/null || true
          done

          printf '\n--- Checkpoint Functions ---\n'
          CHECKPOINT_FUNCS=(
            "save_state"
            "load_state"
            "create_checkpoint"
            "restore_checkpoint"
          )

          for func in "${CHECKPOINT_FUNCS[@]}"; do
            if type -t "$func" &>/dev/null; then
              printf '[AVAILABLE] %s\n' "$func"
            else
              printf '[MISSING] %s\n' "$func"
            fi
          done

      - name: Upload State Management Logs
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: state-management-${{ needs.setup.outputs.artifact_prefix }}
          path: logs/state/
          retention-days: 30

  ################################################################################
  # 20. WORDLIST AND PATTERN TESTING
  # Validate wordlist handling
  ################################################################################
  wordlist-pattern-test:
    name: "20. Wordlist & Patterns"
    runs-on: ubuntu-latest
    needs: setup
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Create Log Directory
        run: mkdir -p logs/wordlist

      - name: Test Wordlist Configuration
        run: |
          set -euo pipefail
          exec > >(tee logs/wordlist/config.log) 2>&1

          printf '%s\n' "=== Testing Wordlist Configuration ==="

          source neko.cfg 2>/dev/null || true

          printf '\n--- Wordlist Variables ---\n'
          WORDLIST_VARS=(
            "SUBS_WORDLIST"
            "SUBS_WORDLIST_SMALL"
            "SUBS_WORDLIST_BIG"
            "FUZZ_WORDLIST"
            "FUZZ_WORDLIST_SMALL"
            "FUZZ_WORDLIST_BIG"
            "LFI_WORDLIST"
            "SQLI_WORDLIST"
            "API_WORDLIST"
            "RESOLVERS"
          )

          for var in "${WORDLIST_VARS[@]}"; do
            if [[ -n "${!var:-}" ]]; then
              printf '[SET] %s = %s\n' "$var" "${!var}"
            else
              printf '[UNSET] %s\n' "$var"
            fi
          done

      - name: Test Pattern Matching
        run: |
          set -euo pipefail
          exec > >(tee logs/wordlist/patterns.log) 2>&1

          printf '%s\n' "=== Testing Pattern Matching ==="

          printf '\n--- Domain Pattern Tests ---\n'
          TEST_DOMAINS=(
            "example.com"
            "sub.example.com"
            "sub.sub.example.com"
            "192.168.1.1"
            "10.0.0.0/24"
          )

          DOMAIN_REGEX='^([a-zA-Z0-9]([a-zA-Z0-9-]*[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$'
          IP_REGEX='^([0-9]{1,3}\.){3}[0-9]{1,3}$'
          CIDR_REGEX='^([0-9]{1,3}\.){3}[0-9]{1,3}/[0-9]{1,2}$'

          for domain in "${TEST_DOMAINS[@]}"; do
            if [[ "$domain" =~ $DOMAIN_REGEX ]]; then
              printf '[DOMAIN] %s\n' "$domain"
            elif [[ "$domain" =~ $IP_REGEX ]]; then
              printf '[IP] %s\n' "$domain"
            elif [[ "$domain" =~ $CIDR_REGEX ]]; then
              printf '[CIDR] %s\n' "$domain"
            else
              printf '[UNKNOWN] %s\n' "$domain"
            fi
          done

      - name: Upload Wordlist Logs
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: wordlist-pattern-${{ needs.setup.outputs.artifact_prefix }}
          path: logs/wordlist/
          retention-days: 30

  ################################################################################
  # 21. ADVANCED FEATURES INTEGRATION
  # Test Bettercap, Blind XSS, etc.
  ################################################################################
  advanced-features-test:
    name: "21. Advanced Features"
    runs-on: ubuntu-latest
    needs: setup
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Create Log Directory
        run: mkdir -p logs/advanced

      - name: Test Advanced Modules
        run: |
          set -euo pipefail
          exec > >(tee logs/advanced/modules.log) 2>&1

          printf '%s\n' "=== Testing Advanced Feature Modules ==="

          source neko.cfg 2>/dev/null || true
          export SCRIPTPATH="$(pwd)"
          export dir="/tmp/neko_adv_$$"
          export called_fn_dir="${dir}/.called"

          mkdir -p "$dir"/{logs,.called}

          for lib in lib/*.sh; do
            source "$lib" 2>/dev/null || true
          done

          ADVANCED_MODULES=(
            "16_advanced_vulns.sh"
            "17_bettercap.sh"
          )

          for module in "${ADVANCED_MODULES[@]}"; do
            printf '\n═══ Module: %s ═══\n' "$module"

            if [[ -f "modules/$module" ]]; then
              if source "modules/$module" 2>/dev/null; then
                printf '[LOADED] Module sourced\n'

                FUNCS=$(grep -E "^[a-z_]+\(\)" "modules/$module" 2>/dev/null | sed 's/().*//' | head -10 || true)
                if [[ -n "$FUNCS" ]]; then
                  printf 'Functions:\n'
                  for func in $FUNCS; do
                    if type -t "$func" &>/dev/null; then
                      printf '  [OK] %s\n' "$func"
                    else
                      printf '  [MISSING] %s\n' "$func"
                    fi
                  done
                fi
              else
                printf '[FAIL] Could not load\n'
              fi
            else
              printf '[SKIP] Module not found\n'
            fi
          done

          rm -rf "$dir" 2>/dev/null || true

      - name: Upload Advanced Features Logs
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: advanced-features-${{ needs.setup.outputs.artifact_prefix }}
          path: logs/advanced/
          retention-days: 30

  ################################################################################
  # 22. DOCUMENTATION CONSISTENCY
  # Verify README matches features
  ################################################################################
  documentation-consistency:
    name: "22. Documentation"
    runs-on: ubuntu-latest
    needs: setup
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Create Log Directory
        run: mkdir -p logs/documentation

      - name: Test README Consistency
        run: |
          set -euo pipefail
          exec > >(tee logs/documentation/readme.log) 2>&1

          printf '%s\n' "=== Testing README Consistency ==="

          if [[ ! -f "README.md" ]]; then
            printf '[FAIL] README.md not found\n'
            exit 0
          fi

          printf '\n--- README Stats ---\n'
          printf 'Lines: %s\n' "$(wc -l < README.md)"
          printf 'Words: %s\n' "$(wc -w < README.md)"

          printf '\n--- Checking documented phases ---\n'
          for i in {0..17}; do
            phase_name=$(printf 'Phase %d' "$i")
            if grep -qi "$phase_name\|phase $i" README.md; then
              printf '[OK] %s documented\n' "$phase_name"
            else
              printf '[MISSING] %s not documented\n' "$phase_name"
            fi
          done

          printf '\n--- Checking documented features ---\n'
          FEATURES=("Discord" "Logging" "Parallel" "Plugin" "Proxy" "Intelligence")

          for feature in "${FEATURES[@]}"; do
            if grep -qi "$feature" README.md; then
              printf '[OK] %s documented\n' "$feature"
            else
              printf '[MISSING] %s not documented\n' "$feature"
            fi
          done

      - name: Test Help Text Accuracy
        run: |
          set -euo pipefail
          exec > >(tee logs/documentation/help_accuracy.log) 2>&1

          printf '%s\n' "=== Testing Help Text Accuracy ==="

          chmod +x neko.sh 2>/dev/null || true

          HELP_OUTPUT=$(./neko.sh --help 2>&1 || true)

          printf '\n--- Documented options in help ---\n'
          OPTIONS=("-d" "--domain" "-a" "--all" "-r" "--recon" "-f" "--fast" "-h" "--help")

          for opt in "${OPTIONS[@]}"; do
            if echo "$HELP_OUTPUT" | grep -q -- "$opt"; then
              printf '[OK] %s in help\n' "$opt"
            else
              printf '[MISSING] %s not in help\n' "$opt"
            fi
          done

      - name: Upload Documentation Logs
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: documentation-${{ needs.setup.outputs.artifact_prefix }}
          path: logs/documentation/
          retention-days: 30

  ################################################################################
  # 23. PERFORMANCE BENCHMARKING
  # Benchmark execution times
  ################################################################################
  performance-benchmark:
    name: "23. Performance Benchmark"
    runs-on: ubuntu-latest
    needs: setup
    if: ${{ github.event.inputs.run_performance_tests == 'true' }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Create Log Directory
        run: mkdir -p logs/performance

      - name: Benchmark Library Loading
        run: |
          set -euo pipefail
          exec > >(tee logs/performance/library_loading.log) 2>&1

          printf '%s\n' "=== Benchmarking Library Loading ==="

          source neko.cfg 2>/dev/null || true
          export SCRIPTPATH="$(pwd)"
          export dir="/tmp/neko_bench_$$"
          export called_fn_dir="${dir}/.called"
          export LOGFILE="${dir}/test.log"
          export TOOLS_PATH="${TOOLS_PATH:-/tmp/Tools}"

          mkdir -p "$dir"/{logs,.called}
          mkdir -p "$TOOLS_PATH"
          touch "$LOGFILE"

          printf '\n--- Individual Library Load Times ---\n'
          for lib in lib/*.sh; do
            libname=$(basename "$lib")
            START=$(date +%s%N)
            source "$lib" 2>/dev/null || true
            END=$(date +%s%N)
            DURATION=$(( (END - START) / 1000000 ))
            printf '%s: %dms\n' "$libname" "$DURATION"
          done

          rm -rf "$dir" 2>/dev/null || true

      - name: Benchmark Module Loading
        run: |
          set -euo pipefail
          exec > >(tee logs/performance/module_loading.log) 2>&1

          printf '%s\n' "=== Benchmarking Module Loading ==="

          source neko.cfg 2>/dev/null || true
          export SCRIPTPATH="$(pwd)"
          export dir="/tmp/neko_modbench_$$"
          export called_fn_dir="${dir}/.called"
          export LOGFILE="${dir}/test.log"
          export TOOLS_PATH="${TOOLS_PATH:-/tmp/Tools}"

          mkdir -p "$dir"/{logs,subdomains,dns,hosts,webs,.called}
          mkdir -p "$TOOLS_PATH"
          touch "$LOGFILE"

          for lib in lib/*.sh; do
            source "$lib" 2>/dev/null || true
          done

          printf '\n--- Individual Module Load Times ---\n'
          for module in modules/*.sh; do
            modname=$(basename "$module")
            START=$(date +%s%N)
            source "$module" 2>/dev/null || true
            END=$(date +%s%N)
            DURATION=$(( (END - START) / 1000000 ))
            printf '%s: %dms\n' "$modname" "$DURATION"
          done

          rm -rf "$dir" 2>/dev/null || true

      - name: Upload Performance Logs
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: performance-${{ needs.setup.outputs.artifact_prefix }}
          path: logs/performance/
          retention-days: 30

  ################################################################################
  # 24. ENVIRONMENT SETUP VALIDATION
  # Test setup scripts
  ################################################################################
  environment-setup-validation:
    name: "24. Environment Setup"
    runs-on: ubuntu-latest
    needs: setup
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Create Log Directory
        run: mkdir -p logs/setup

      - name: Test Install Script Syntax
        run: |
          set -euo pipefail
          exec > >(tee logs/setup/install_syntax.log) 2>&1

          printf '%s\n' "=== Testing Install Script Syntax ==="

          if [[ -f "install.sh" ]]; then
            if bash -n install.sh 2>&1; then
              printf '[PASS] install.sh syntax valid\n'
            else
              printf '[FAIL] install.sh has syntax errors\n'
            fi

            printf '\n--- Install Script Functions ---\n'
            FUNCS=$(grep -E "^[a-z_]+\(\)" install.sh 2>/dev/null | sed 's/().*//' || true)
            for func in $FUNCS; do
              printf '  %s\n' "$func"
            done
          else
            printf '[SKIP] install.sh not found\n'
          fi

      - name: Test Directory Structure Creation
        run: |
          set -euo pipefail
          exec > >(tee logs/setup/directory_structure.log) 2>&1

          printf '%s\n' "=== Testing Directory Structure Creation ==="

          TEST_BASE="/tmp/neko_setup_test_$$"

          EXPECTED_DIRS=(
            "logs"
            "osint"
            "subdomains"
            "dns"
            "hosts"
            "webs"
            "ports"
            "content"
            "technologies"
            "urls"
            "js"
            "parameters"
            "vulnerabilities"
            "xss"
            "takeover"
            "cloud"
            "auth"
            "api"
            "reports"
            ".tmp"
            ".called"
          )

          mkdir -p "$TEST_BASE"
          for dir in "${EXPECTED_DIRS[@]}"; do
            mkdir -p "$TEST_BASE/$dir"
          done

          printf '\n--- Created directories ---\n'
          for dir in "${EXPECTED_DIRS[@]}"; do
            if [[ -d "$TEST_BASE/$dir" ]]; then
              printf '[OK] %s\n' "$dir"
            else
              printf '[FAIL] %s\n' "$dir"
            fi
          done

          rm -rf "$TEST_BASE" 2>/dev/null || true

      - name: Upload Setup Logs
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: environment-setup-${{ needs.setup.outputs.artifact_prefix }}
          path: logs/setup/
          retention-days: 30

  ################################################################################
  # 25. FINAL SUMMARY AND ARTIFACT COLLECTION
  ################################################################################
  final-summary:
    name: "25. Final Summary"
    runs-on: ubuntu-latest
    needs: [
      setup,
      integration-testing,
      library-dependency-testing,
      module-function-coverage,
      config-validation-suite,
      tool-mock-testing,
      error-handling-recovery,
      parallel-processing-test,
      orchestrator-workflow-test,
      data-flow-bus-test,
      intelligence-engine-test,
      plugin-system-test,
      logging-system-validation,
      proxy-network-test,
      output-format-test,
      security-permissions-test,
      resource-usage-test,
      cli-interface-test,
      state-management-test,
      wordlist-pattern-test,
      advanced-features-test,
      documentation-consistency,
      environment-setup-validation
    ]
    if: always()
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Generate Final Summary
        run: |
          set -euo pipefail

          cat > final-summary.txt << 'SUMMARY'
          ╔══════════════════════════════════════════════════════════════════════════════╗
          ║                    NEKO COMPREHENSIVE TESTING SUITE                          ║
          ║                           FINAL SUMMARY REPORT                               ║
          ╠══════════════════════════════════════════════════════════════════════════════╣
          SUMMARY

          printf '║ Run ID: %s\n' "${{ needs.setup.outputs.run_id }}" >> final-summary.txt
          printf '║ Timestamp: %s\n' "$(date '+%Y-%m-%d %H:%M:%S')" >> final-summary.txt
          printf '║ Event: %s\n' "${{ github.event_name }}" >> final-summary.txt
          printf '║ Ref: %s\n' "${{ github.ref }}" >> final-summary.txt
          printf '╠══════════════════════════════════════════════════════════════════════════════╣\n' >> final-summary.txt
          printf '║                              TEST RESULTS                                    ║\n' >> final-summary.txt
          printf '╠══════════════════════════════════════════════════════════════════════════════╣\n' >> final-summary.txt

          JOBS=(
            "integration-testing:1. Integration Testing"
            "library-dependency-testing:2. Library Dependencies"
            "module-function-coverage:3. Module Functions"
            "config-validation-suite:4. Config Validation"
            "tool-mock-testing:5. Tool Mock Testing"
            "error-handling-recovery:6. Error Handling"
            "parallel-processing-test:7. Parallel Processing"
            "orchestrator-workflow-test:8. Orchestrator"
            "data-flow-bus-test:9. Data Flow Bus"
            "intelligence-engine-test:10. Intelligence Engine"
            "plugin-system-test:11. Plugin System"
            "logging-system-validation:12. Logging System"
            "proxy-network-test:13. Proxy & Network"
            "output-format-test:14. Output Formats"
            "security-permissions-test:15. Security"
            "resource-usage-test:16. Resources"
            "cli-interface-test:18. CLI Interface"
            "state-management-test:19. State Management"
            "wordlist-pattern-test:20. Wordlists"
            "advanced-features-test:21. Advanced Features"
            "documentation-consistency:22. Documentation"
            "environment-setup-validation:24. Environment Setup"
          )

          for job_info in "${JOBS[@]}"; do
            job_id="${job_info%%:*}"
            job_name="${job_info##*:}"
            printf '║ %-35s [COMPLETED]\n' "$job_name" >> final-summary.txt
          done

          printf '╠══════════════════════════════════════════════════════════════════════════════╣\n' >> final-summary.txt
          printf '║ All test artifacts have been uploaded for detailed analysis.                ║\n' >> final-summary.txt
          printf '║ Download the artifacts to review detailed logs for each test category.      ║\n' >> final-summary.txt
          printf '╚══════════════════════════════════════════════════════════════════════════════╝\n' >> final-summary.txt

          cat final-summary.txt

      - name: Upload Final Summary
        uses: actions/upload-artifact@v4
        with:
          name: final-summary-${{ needs.setup.outputs.artifact_prefix }}
          path: final-summary.txt
          retention-days: 30